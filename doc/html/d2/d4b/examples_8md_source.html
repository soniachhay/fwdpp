<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>fwdpp: md/examples.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.5.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">md/examples.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d2/d4b/examples_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Example programs</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The best documentation of how to use the library are the example simulations in the examples/ subdirectory of the source code repo.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;### Running the examples:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This following list of parameters and their definitions is in common to all of the example programs:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;* N = the number of diploid individuals to simulate</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;* theta = 4Nu, where u is the mutation rate per gamete per generation. For example, theta = 100 means that on average, 2Nu = 50 new mutations are entering the population each generation.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;* rho = 4Nr, where r is the recombination rate per diploid per generation</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;* g = the number of generations to simulate. Often, this should be &gt;= 8N at a minimum</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* n = the sample size to draw at the end of the simulation. To match the typical modeling assumptions of population genetics, you should have n &lt;&lt; 2N.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* nreps = the number of replicates to simulate</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* seed = a random number seed. I will use $RANDOM as a seed, referring to the bash shell method to return a random integer.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;Note: familiarity with Hudson&#39;s &quot;[ms](http://home.uchicago.edu/~rhudson1)&quot; program is helpful for some of what comes below.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;#### diploid_ind (diploid_ind.cc)</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;The first program, diploid, simulates a Wright-Fisher population with mutation, recombination, and drift. To run it:</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;~~~</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;./diploid_ind N theta rho g n nreps seed | gzip &gt; outfile.gz</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;~~~</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;The data in outfile.gz will be in the same format as Dick Hudson&#39;s &quot;ms&quot; coalescent simulator.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Example:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;~~~</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;./diploid_ind 10000 10 10 100000 50 1 $RANDOM | gzip &gt; test_diploid.gz</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;~~~</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;#### diploid\_binaryIO_ind (diploid_binaryIO_ind.cc)</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;The next program is called diploid\_binaryIO\_ind. This program is identical to diploid, except that it only simulates one replicate at a time, creates two output files, and outputs the entire population rather than a sample of size n &lt;&lt; 2N. The first file is an index file, containing an integer representing the replicate number of the output and the position in the haplotypes file where this record begins. The second file is the haplotypes file, which contains the entire population in binary format. </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;Usage:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;~~~</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;./diploid_binaryIO N theta rho g replicate\_number index\_filename haplotype\_filename seed.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;~~~</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;Example for Open Grid Engine compute clusters:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;~~~{.sh}</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;#!sh</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;#$ -t 1-100</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;#$ -N DIPBIN</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;seed=`echo &quot;$SGE_TASK_ID*$RANDOM&quot;|bc -l`</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;~~~</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;\#note: the below assumes that the binary is in the users&#39;s $PATH and that the GE system knows how to link it to the relevant dynamic libraries</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;~~~</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;diploid_binaryIO_ind 10000 10 10 100000 $SGE_TASK_ID indexfile hapfile $seed</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;~~~</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;The above script, when submitted to a Grid Engine queue, will result in 100 populations of size N=10,000 being written to hapfile. Further, “indexfile” will contain the ID number and position of each file. Records are not over-written because the program uses POSIX file locking to ensure that only 1 process at a time can do the writing. This is a complex program, as it mixes C++ objects with output streams such that they can be written to C-style file descriptors, which is required in order to use file locking (which is a C feature with no C++ analog). However, the advantage is that you write all data to one large file, avoiding the plague of lots of small files that can bring distributed file systems to their knees.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;#### diploid\_fixed\_sh\_ind (diploid_fixed_sh\_ind.cc) and diploid\_fixed\_sh\_ind_lambda (diploid_fixed_sh_ind_lambda.cc)</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;This program is similar to diploid_ind, but adds an additional mutation rate (theta\_selected = 4Nu\_s, where u\_s is the mutation rate per gamete per generation to mutations with selection coefficient s) to mutations with selection coefficient s and dominance h. Fitness across sites is multiplicative. The output is in &quot;ms&quot; format--one block for neutral mutations followed by one block for selected mutations.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;Usage:</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;~~~</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;./dipoid_fixed_sh_ind N theta theta_selected rho s h g n nreps seed | gzip &gt; outfile.gz</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;~~~</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;For this program, s can be positive or negative, as can h.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;#### diploid\_twopop\_mig\_ind (diploid_twopop_mig_ind.cc)</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;This program simulates an ancestral population for g generations, at which point a daughter population of size N is “budded” off from the ancestral population. Evolution continues for g2 more generations, with symmetric migration at rate M = 4Nm, where m is the migration rate per diploid per generation. The output is in &quot;ms&quot; format, with n haplotypes per sample just like how ms outputs data for multi-population models.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;Usage:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;~~~</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;./diploid_twopop_mig_ind N theta rho g g2 M n nreps seed | gzip &gt; outfile.gz</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;~~~</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;Note: the demographic model here implemented may be viewed as biologically bizarre, as it mimics the default behavior of “ms” for population split models. Let’s compare a specific example vs. the equivalent ms command line:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;~~~</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;./diploid_twopop_mig 10000 50 50 100000 1000 1 50 1 $RANDOM | gzip &gt; outfile.gz</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;~~~</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;and</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;~~~</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;ms 100 1 -t 50 -r 50 1000 -I 2 2 1 -ej 0.025 2 1 -em 0.025 1 2 0.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;~~~</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;Why may this be considered odd? In ms, when two populations are merged, the rate of coalescence is unaffected by default (this behavior is documented, and it is up to the user to adjust population sizes when population merge and split in ms). That means when the two populations, each of size N merge, the merged (ancestral) population is still of size N. diploid\_twopop\_mig is doing the same thing forwards in time: an ancestral population of size N magically changes into two populations of size N. </div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;#### migsel\_ind (migsel_ind.cc)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;Simulates 2 equal-sized populations of size N (N remains constant over time) diploids with selection at strength s and dominance h. Migration occurs between the two populations.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;_Note that the two populations never share a common ancestor in this simulation!  In other words, deme 1 is never founded by a sampling event from deme 0.  This means that if you simulate for a short period of time, it is unlikely that there is a MRCA common to all individuals sampled.  (See comment above about appropriateness of these examples for research...)_</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;Usage:</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;~~~</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;./migsel_ind N 4Nu_neut 4Nu_sel 4Nr 4Nm s h f1 f2 ngens n outfilename seed</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;~~~</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;where:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;* N = population number for each deme.</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;* 4Nu\_neut = 4N times the neutral mutation rate per gamete</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;* 4Nu\_sel = 4N times the mutation rate per gamete to selected mutations</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;* 4Nr = 4N times the recombination rate per diploid per region per generation</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;* 4Nm = 4N times the probability of migration per diploid per generation</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;* s = the selection coefficient of newly-arising selected mutations</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;* h = dominance of newly-arising selected mutations</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;* f1 and f2 are the probabilities of inbreeding in deme 1 and 2, respectively</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;* ngens = # of generations to simulate</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;* n = sample size to take from each deme @ end of simulation (must be even #)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;* outfilename = name of output file</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;* seed = random number seed.</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;Notes: s is taken to be s in deme 1 and -s in deme 2. This lets me illustrate how different fitness functions can be passed to different demes using fwdpp.</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;The output file contains the following:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;1. The metapopulation in binary format</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;2. Two &quot;ms&quot;-format blocks of size 2*n. These are for neutral and selected mutations, respectively. Within each block, the first n haplotypes are from deme 1 and the second n are from deme 2.</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;The program writes the data to the output file and then reads it in again. This is mainly to illustrate the binary I/O routines for individual-based metapopulation simulations.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;#### migsel\_split\_ind (migsel_split_ind.cc) and migsel\_split\_ind\_list (migsel_split_ind_list.cc)</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;__NOTE:__ migsel_split_ind is not longer compiled as of fwdpp 0.3.0.  It may be resurrected in the future.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;Simulates a constant-sized population of N diploids with selection at strength s and dominance h for ngens generations. Then, a copy is made of the population, and the two demes are simulated with migration for another ngens2 generations.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;These two programs also serialize their data, read the copied data back, and make sure that input equals output.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;These two examples are hints on how to code up &quot;IM&quot;-like models.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;Usage:</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;~~~</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;./migsel_split_ind N 4Nu_neut 4Nu_sel 4Nr 4Nm s h f1 f2 ngens ngens2 n seed</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;~~~</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;~~~</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;./migsel_split_ind_list N 4Nu_neut 4Nu_sel 4Nr 4Nm s h f1 f2 ngens ngens2 n seed</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;~~~</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;where:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;* N = population number for each deme.</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;* 4Nu\_neut = 4N times the neutral mutation rate per gamete</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;* 4Nu\_sel = 4N times the mutation rate per gamete to selected mutations</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;* 4Nr = 4N times the recombination rate per diploid per region per generation</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;* 4Nm = 4N times the probability of migration per diploid per generation</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;* s = the selection coefficient of newly-arising selected mutations</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;* h = dominance of newly-arising selected mutations</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;* f1 and f2 are the probabilities of inbreeding in deme 1 and 2, respectively</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;* ngens = # of generations to simulate</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;* ngens2 = # of generations to simulate after the split</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;* n = sample size to take from each deme @ end of simulation (must be even #)</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;* seed = random number seed.</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;Notes: s is taken to be s in deme 1 and -s in deme 2. This lets me illustrate how different fitness functions can be passed to different demes using fwdpp.</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;#### bneck\_selection\_ind (bneck_selection_ind.cc)</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;This program simulates a population for g generations at size N. In generation g+1, N changes to N2 &lt;= N. The population then grows exponentially to size N3 &gt;= N2 in g2 generations. Selected and neutral mutations are allowed each generation. The output is in “ms” format--one block for neutral mutations followed by one block for selected mutations.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;Usage:</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;~~~</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;./bneck_selection_ind N theta_neutral theta_sel rho s h g1 N2 N3 g2 n nreps seed</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;~~~</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;Where:</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;* N = starting population size</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;* theta\_neutral = 4N*(neutral mutation rate per gamete)</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;* theta\_sel = 4N*(mutation rate per gamete to selected mutations)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;* rho = 4Nr, where r is recombination rate per diploid per generation</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;* s = selection coefficient. Can be negative or positive.</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;* h = dominance of selected mutations</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;* N2 = size of bottlenecked population</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;* N3 = size of recovered population</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;* g2 = generations taken to go from size N2 to size N3</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;* n = sample size to take from the population.</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;* nreps = # replicates to simulate</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;* seed = random number seed.</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;#### diploid\_ind\_2locus (diploid_ind_2locus.cc)</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;This program simulates a 2-locus neutral model.  Mutations arise at rate \f$\theta\f$ at each locus, and each locus recombines at rate \f$\rho\f$.  The recombination rate between loci is \f$r_{bw}\f$, which corresponds to the probability a crossover is observed between loci.  In other words, the genotypes at the two loci will switch from \f[\frac{AB}{ab}\f] to \f[\frac{Ab}{aB}\f] with probability \f$r_{bw}\f$.</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;The output of the simulation is an &quot;ms&quot;-style block for each locus. Positions  are uniform on the interval \f$[0,1)\f$ at locus 1, and uniform on the interval \f$[1,2)\f$ at locus 2.</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;The usage is:</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;~~~</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;Usage:</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;./diploid_ind_2locus N theta rho rbw ngens n nreps seed</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;Where:</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;N = population size (number of diploids)</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;theta = 4Nu, the scaled neutral mutation rate</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;rho = 4Nr, the scale recombination rate</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;rbw = the probability that the two loci cross over, per generation</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;ngens = the number of generations to simulate</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;n = the sample size to pull from the population at the end of each simulated replicate</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;nreps = the number of replicates to simulated</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;seed = seed value for random number generations</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;~~~</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;#### HOC_ind (HOC_ind.cc)</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;This program simulates a little twist on Turelli&#39;s House-of-Cards (HOC) model.  The main point of this model is to demonstrate how to use KTfwd::tags::gamete_dependent to implement mutation models that depend on the current gamete state.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;In a typical HOC model (Kingman), the effect size of a mutated allele is a new draw from a Gaussian distribution.  In this simulation, the current effect size of an allele, before mutation, is additive over causative mutations, with sum \f$y\f$.  After the addition of a single mutation, its new effect size will be \f$x\f$, and thus the effect size of the new mutation, \f$e\f$, is chosen such that \f$x = y+e\f$.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;The fitness model here is Gaussian stabilizing selection with a mean of 0 and a standard deviation of 1.  With this fitness function and the additive model of Turelli, \f$V(G) \approx 4\mu\f$ when the ratio of the variance in effect sizes over the variance in fitness falls within a certain range.  That approximation seems to hold, at least roughly, for this odd method of generating the effect sizes of new variants.  For example, these commands return a mean of approximately \f$4 \times 10^{-4}\f$</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;~~~</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;#Generate 100 seeds</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;Rscript -e &quot;cat(as.integer(runif(1e2,0,1e6)),sep=\&quot;\n\&quot;)&quot; &gt; seeds</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;#run jobs in parallel on a 4-core machine, write VG to a file</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;parallel --jobs 4 ./HOC_ind 10000 0.0001 0.25 0 100000 1 {} :::: seeds &gt; VG.txt</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;~~~</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;The usage is:</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;~~~</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;Usage: ./HOC_ind N mu sigmu rho ngens nreps seed</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;where:</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;N = diploid population size</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;mu = mutation rate to variants affecting fitness</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;sigmu = standard deviation of effect sizes.  E ~ N(0,sigmu^2)</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;4Nr = population scaled recombination rate (per diploid, per generation)</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;ngens = number of generations to simulate</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;nreps = number of replicates to simulate</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;seed = random number seed</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;~~~</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;The only output is \f$V(G)\f$, the genetic variance in fitness, which is written to stdout for each replicate.</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
