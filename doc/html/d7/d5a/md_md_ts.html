<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: Tree sequences</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tree sequences </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>fwdpp 0.7.0 introduced support for generating "succinct tree sequences" during simulations. See <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2016-cb">[1]</a> for background on the data structures and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> on their application to forward simulation.</p>
<p>Some readers will probably find the <a href="https://msprime.readthedocs.io/en/stable/">msprime documentation</a> helpful here, as many of the big-picture concepts are the same. The relevant section of that documentation is titled "Tree sequence interchange".</p>
<h2>Example programs</h2>
<p>I encourage you to read the <a href="https://tskit-dev.github.io/tutorials/">tutorials</a> that we have written for the tskit project. The tutorials on forward-time simulation give an overview of the logic of a simulation. While the overall idea of "generate nodes and edges, simplify every now and then, repeat" is straightforward, there are some gotchas that tripped up the authors of <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> more than a few times.</p>
<ol type="1">
<li>wfts.cc implements a Wright-Fisher simulation with selection, ancestral sample recording, and ancestral sample metadata tracking. Command line switches also enable extensive testing of the data structures.</li>
<li><a class="el" href="../../d2/df8/spatialts_8cc.html">spatialts.cc</a> implements a simplistic method of simulating discrete generations on a continuous landscape. The methods used in this example are <b>not</b> what one would do in research-quality code. Rather, the example is illustrative, and shows how the geographic locations of preserved samples may be tracked.</li>
</ol>
<h2>Namespace</h2>
<p>Tree sequence support is found in namespace <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html" title="Tree sequence  support. ">fwdpp::ts</a>. Like the rest of fwdpp, it is header-only.</p>
<h2>Data types</h2>
<ol type="1">
<li>Nodes and edges are defined by <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a> and <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html" title="An edge in a tree sequence. ">fwdpp::ts::edge</a>, respectively.</li>
<li>Mutations are tracked on trees via <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">fwdpp::ts::mutation_record</a>.</li>
</ol>
<p>Node, edge, and mutation tables are stored as vectors of the above three types.</p>
<p><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a> holds node, edge, and mutation tables.</p>
<p><a class="el" href="../../dc/d0a/classfwdpp_1_1ts_1_1table__simplifier.html" title="Implements the simplification algorithm of . ">fwdpp::ts::table_simplifier</a> is responsible for applying the simplification algorithm of <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> to a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>.</p>
<h2>Relationship to msprime/tskit</h2>
<p>I'll refer to <em>tskit</em> here, which means the part of msprime dealing with tree sequences.</p>
<ol type="1">
<li>Node times are measured forwards in time. See <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a>.</li>
<li>The mutation table is simply a vector of records tracking nodes where mutations occur on the tree and their indexes in the population. See <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">fwdpp::ts::mutation_record</a>. Thus, the concept of a "sites table" and a "mutation table" are merged in fwdpp.</li>
<li>The default storage format is a custom format. Once a standalone tskit C library is available, we will likely provide direct access to storage in that tree file format as well. The current binary format is required for things like MPI, Python pickling, etc., though, so it'll stick around.</li>
</ol>
<h2>Iterating over trees</h2>
<p><a class="el" href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html" title="Class that iterates over marginal trees. ">fwdpp::ts::tree_visitor</a> iterates over the non-recombining segments ("marginal trees") in the pedigree. This type defines a call operator that handles the iteration, updating an internal variable of type <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a>.</p>
<div class="image">
<img src="../../tree.png" alt="tree.png"/>
<div class="caption">
A simplified, fully-coalesced marginal tree</div></div>
<p> Consider the tree shown above. It has 7 nodes. The parent list of the tree is represented as a linear vector (<a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html#a4e8a7ee32191ef5b8d32731d9b71143b">fwdpp::ts::marginal_tree::parents</a>), and would contain the following values:</p>
<div class="fragment"><div class="line">4 4 5 5 6 6 fwdpp::ts::TS_NULL_NODE</div></div><!-- fragment --><p>The final value, which is the parent of the node labelled <b>6</b>, is <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a3b6e884129b83242fc56f14784a2a3d8" title="Index value of a NULL node. ">fwdpp::ts::TS_NULL_NODE</a>, which signifies that there is no parent.</p>
<p>Iteration over parents is trivial:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> visit_parents(<span class="keyword">const</span> <a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">fwdpp::ts::TS_NODE_INT</a> n, <span class="keyword">const</span> <a class="code" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">fwdpp::ts::marginal_tree</a> &amp; m)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> p = n;</div><div class="line">    <span class="keywordflow">while</span> (p != <a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#a3b6e884129b83242fc56f14784a2a3d8">fwdpp::ts::TS_NULL_NODE</a>)</div><div class="line">        {</div><div class="line">            p = m.<a class="code" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html#a4e8a7ee32191ef5b8d32731d9b71143b">parents</a>[p];</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>Of course, a real-world application would have to provide bounds-checking, and would probably actually <em>do</em> something with <code>p</code> at each iteration.</p>
<h3>Traversing the nodes in a tree</h3>
<p>In general, a node table is as least as large as the number of nodes in any one tree. We therefore need a way to access the nodes that actually <em>are</em> in a given tree. The class <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">fwdpp::ts::node_iterator</a> facilitates efficient traversal of the nodes in a <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a>. Direct interaction with <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html" title="Tree sequence  support. ">fwdpp::ts</a>:node_iterator is often unnecessary. It will often be more convenient to use the function <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4f7ef15ad73a3fae551eab0b7ade304c">fwdpp::ts::process_nodes</a>. For example, to obtain a mapping of nodes to the number of children descending from each node:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../dd/d76/marginal__tree__functions_8hpp.html">fwdpp/ts/marginal_tree_functions.hpp</a>&gt;</span></div><div class="line"></div><div class="line">std::vector&lt;std::pair&lt;fwdpp::ts::TS_NODE_INT, int&gt;&gt;</div><div class="line">nchildren_per_node(<span class="keyword">const</span> <a class="code" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">fwdpp::ts::marginal_tree</a> &amp; m)</div><div class="line">{</div><div class="line">        std::vector&lt;std::pair&lt;fwdpp::ts::TS_NODE_INT, int&gt;&gt; rv;</div><div class="line">        <a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4f7ef15ad73a3fae551eab0b7ade304c">fwdpp::ts::process_nodes</a>(m,</div><div class="line">                                 <a class="code" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html">fwdpp::ts::nodes_preorder</a>(),</div><div class="line">                                 [&amp;m,&amp;rv](<a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">fwdpp::ts::TS_NODE_INT</a> u)</div><div class="line">                                 {</div><div class="line">                                         rv.emplace_back(u, <a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08036aaea8b364c31930ad309a6cc56b">fwdpp::ts::num_children</a>(m,u));</div><div class="line">                                 });</div><div class="line">        <span class="keywordflow">return</span> rv;</div><div class="line">}</div></div><!-- fragment --><p>Internally, the above code constructs a <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">fwdpp::ts::node_iterator</a> object that conducts a preorder traversal of <em>m</em>. The type <a class="el" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html" title="Dispatch tage for node_traversal_preorder. ">fwdpp::ts::nodes_preorder</a> is a dispatch tag that facilitates the dependency injection of the traversal order policy when constructing the <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">fwdpp::ts::node_iterator</a>. The lambda function gets the number of children for each node via a call to <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08036aaea8b364c31930ad309a6cc56b" title="Return number of children of a node. ">fwdpp::ts::num_children</a> (which dispatches its own work to <a class="el" href="../../d3/ddc/classfwdpp_1_1ts_1_1child__iterator.html" title="Faciliate traversal of a node&#39;s children. ">fwdpp::ts::child_iterator</a>).</p>
<p>The library provide classes and functions for iterating over the tree roots and the children of nodes:</p>
<ul>
<li><a class="el" href="../../d0/da6/classfwdpp_1_1ts_1_1root__iterator.html">fwdpp::ts::root_iterator</a> allows left-to-right traversal of all nodes in a <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a></li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08d54fd20651e657d980cc9aa908a22e" title="Return number of roots. ">fwdpp::ts::num_roots</a> returns the number of roots in a <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a></li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a9ba9096050c56e50c5216e50baf0520a" title="Get a vector of all roots. ">fwdpp::ts::get_roots</a> returns a vector of the roots of the tree.</li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a32ca473e8d52b278e20a4edbbc711cf5" title="Apply a function to all roots. ">fwdpp::ts::process_roots</a> allows a function to be applied to all roots of a tree.</li>
<li><a class="el" href="../../d3/ddc/classfwdpp_1_1ts_1_1child__iterator.html" title="Faciliate traversal of a node&#39;s children. ">fwdpp::ts::child_iterator</a> allows left-to-right or right-to-left iteration over all children of a node.</li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08036aaea8b364c31930ad309a6cc56b" title="Return number of children of a node. ">fwdpp::ts::num_children</a> returns the number of children descending from a node</li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab503ae0e38aeb913c55266665feb3152" title="Get all children of a node. ">fwdpp::ts::get_children</a> returns a vector of the children descending from a node</li>
<li><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a99b7ce7325002612b10ddc46b831203b" title="Apply a function to children of node n. ">fwdpp::ts::process_children</a> allows a function to be applied to all children of a node.</li>
</ul>
<p>The classes and functions listed above may be included via <a class="el" href="../../dd/d76/marginal__tree__functions_8hpp.html">fwdpp/ts/marginal_tree_functions.hpp</a> or via the individual headers included therein.</p>
<h4>Node traversal order</h4>
<p>The node traversal method is determined by a dependency injection into <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">fwdpp::ts::node_iterator</a>. The dependency must publicly inherit from the abstract class <a class="el" href="../../d6/dd0/structfwdpp_1_1ts_1_1node__traversal__order.html" title="Interface class for dependency injection into node_iterator. ">fwdpp::ts::node_traversal_order</a>. The construction of a <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">fwdpp::ts::node_iterator</a> object is done via tag dispatch to a function called <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a071367c1dd58b17e5d2c50c87b52f4e0" title="Handles dependency injection of node_traversal_preorder into node_iterator. ">fwdpp::ts::node_traversal_dispatch</a>. For example, setting up preorder traversal works like this:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html">fwdpp::ts::node_iterator</a> mi(m, <a class="code" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html">fwdpp::ts::nodes_preorder</a>());</div></div><!-- fragment --><p>The reason to use tag dispatch here is that you may implement a traversal order that fwdpp does not provide. To do so, you have to include <a class="el" href="../../d8/dbc/node__traversal__order_8hpp.html">fwdpp/ts/marginal_tree_functions/node_traversal_order.hpp</a> and define your new class, a tag dispatch struct and an overload of node_traversal_dispatch <b>before</b> including <a class="el" href="../../dd/d76/marginal__tree__functions_8hpp.html">fwdpp/ts/marginal_tree_functions.hpp</a> or <a class="el" href="../../de/d38/nodes_8hpp.html">fwdpp/ts/marginal_tree_functions/nodes.hpp</a>. For a concrete example, see the implementation of <a class="el" href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html" title="Preorder traversal of nodes for a node_iterator. ">fwdpp::ts::node_traversal_preorder</a>. Note that you do not need to put your own classes and functions into the fwdpp namespaces because argument-dependent lookup (ADL) should apply here, which is tested in the test suite. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
