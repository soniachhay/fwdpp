<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: fwdpp::ts Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></li><li class="navelem"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html">ts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fwdpp::ts Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Tree sequence <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/d89/namespacefwdpp_1_1ts_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/namespacefwdpp_1_1ts_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d5d/namespacefwdpp_1_1ts_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5d/namespacefwdpp_1_1ts_1_1io.html">io</a></td></tr>
<tr class="memdesc:da/d5d/namespacefwdpp_1_1ts_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary seriazliation of <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">all_mutations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddc/classfwdpp_1_1ts_1_1child__iterator.html">child_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Faciliate traversal of a node's children.  <a href="../../d3/ddc/classfwdpp_1_1ts_1_1child__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8f/structfwdpp_1_1ts_1_1convert__sample__index__to__nodes__t.html">convert_sample_index_to_nodes_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge in a tree sequence.  <a href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-recombining tree.  <a href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6a/structfwdpp_1_1ts_1_1new__variant__record.html">new_variant_record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html">node_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse nodes in a <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a>.  <a href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd0/structfwdpp_1_1ts_1_1node__traversal__order.html">node_traversal_order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for dependency injection into <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">node_iterator</a>.  <a href="../../d6/dd0/structfwdpp_1_1ts_1_1node__traversal__order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html">node_traversal_preorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preorder traversal of nodes for a <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">node_iterator</a>.  <a href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html">nodes_preorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch tage for <a class="el" href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html" title="Preorder traversal of nodes for a node_iterator. ">node_traversal_preorder</a>.  <a href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da6/classfwdpp_1_1ts_1_1root__iterator.html">root_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d22/structfwdpp_1_1ts_1_1sample__group__map.html">sample_group_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a node id to a sample group.  <a href="../../dd/d22/structfwdpp_1_1ts_1_1sample__group__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db8/classfwdpp_1_1ts_1_1samples__error.html">samples_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d13/classfwdpp_1_1ts_1_1samples__iterator.html">samples_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Faciliate traversal of the samples descending from a node.  <a href="../../d7/d13/classfwdpp_1_1ts_1_1samples__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">selected_variants_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfd/classfwdpp_1_1ts_1_1site__visitor.html">site_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitae iteration over <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">ts::site</a> objects one at a time For example use, see implementation of <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a0de7adfaff962a474c591150487bd909">ts::generate_data_matrix</a>.  <a href="../../da/dfd/classfwdpp_1_1ts_1_1site__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of tables for a single simulation.  <a href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0a/classfwdpp_1_1ts_1_1table__simplifier.html">table_simplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the simplification algorithm of <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a>.  <a href="../../dc/d0a/classfwdpp_1_1ts_1_1table__simplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d77/classfwdpp_1_1ts_1_1tables__error.html">tables_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html">tree_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that iterates over marginal trees.  <a href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfc/structfwdpp_1_1ts_1_1update__samples__list__t.html">update_samples_list_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af35a0875d0656933d78cc7840a662aa5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> = std::int32_t</td></tr>
<tr class="memdesc:af35a0875d0656933d78cc7840a662aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type for node indexes.  <a href="#af35a0875d0656933d78cc7840a662aa5">More...</a><br /></td></tr>
<tr class="separator:af35a0875d0656933d78cc7840a662aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa2800d3ad3222f919e113cac33706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab8aa2800d3ad3222f919e113cac33706">indexed_edge_container</a> = std::vector&lt; <a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a> &gt;</td></tr>
<tr class="separator:ab8aa2800d3ad3222f919e113cac33706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b5522130bcd6ca8feeb86276b0807"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aff3b5522130bcd6ca8feeb86276b0807">edge_vector</a> = std::vector&lt; <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &gt;</td></tr>
<tr class="separator:aff3b5522130bcd6ca8feeb86276b0807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c51e69b27f3e160eb62ea06591a2bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a60c51e69b27f3e160eb62ea06591a2bb">node_vector</a> = std::vector&lt; <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &gt;</td></tr>
<tr class="separator:a60c51e69b27f3e160eb62ea06591a2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fa9d4b0f7f967c76a8d550102a7405"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37fa9d4b0f7f967c76a8d550102a7405">mutation_key_vector</a> = std::vector&lt; <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &gt;</td></tr>
<tr class="separator:a37fa9d4b0f7f967c76a8d550102a7405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a651f970d62175ab2a39a926ef384be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a5a651f970d62175ab2a39a926ef384be">site_vector</a> = std::vector&lt; <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &gt;</td></tr>
<tr class="memdesc:a5a651f970d62175ab2a39a926ef384be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Site table.  <a href="#a5a651f970d62175ab2a39a926ef384be">More...</a><br /></td></tr>
<tr class="separator:a5a651f970d62175ab2a39a926ef384be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032633feb419313c220ff0fd18d3a594"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a032633feb419313c220ff0fd18d3a594">update_samples_list</a> = <a class="el" href="../../dd/d53/structfwdpp_1_1strong__types_1_1named__type.html">strong_types::named_type</a>&lt; bool, <a class="el" href="../../d1/dfc/structfwdpp_1_1ts_1_1update__samples__list__t.html">update_samples_list_t</a> &gt;</td></tr>
<tr class="memdesc:a032633feb419313c220ff0fd18d3a594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy dictating if a <a class="el" href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html" title="Class that iterates over marginal trees. ">tree_visitor</a> updates sample lists.  <a href="#a032633feb419313c220ff0fd18d3a594">More...</a><br /></td></tr>
<tr class="separator:a032633feb419313c220ff0fd18d3a594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6529ade4ad161b3e22bb12bc537eafe2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a6529ade4ad161b3e22bb12bc537eafe2">convert_sample_index_to_nodes</a> = <a class="el" href="../../dd/d53/structfwdpp_1_1strong__types_1_1named__type.html">strong_types::named_type</a>&lt; bool, <a class="el" href="../../d6/d8f/structfwdpp_1_1ts_1_1convert__sample__index__to__nodes__t.html">convert_sample_index_to_nodes_t</a> &gt;</td></tr>
<tr class="memdesc:a6529ade4ad161b3e22bb12bc537eafe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy affecting behavior of <a class="el" href="../../d7/d13/classfwdpp_1_1ts_1_1samples__iterator.html" title="Faciliate traversal of the samples descending from a node. ">samples_iterator</a>.  <a href="#a6529ade4ad161b3e22bb12bc537eafe2">More...</a><br /></td></tr>
<tr class="separator:a6529ade4ad161b3e22bb12bc537eafe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae61878d866a30350e082ce879e8a1a4"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES , typename mcont_t &gt; </td></tr>
<tr class="memitem:aae61878d866a30350e082ce879e8a1a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aae61878d866a30350e082ce879e8a1a4">count_mutations</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const mcont_t &amp;mutations, SAMPLES &amp;&amp;samples, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;mcounts)</td></tr>
<tr class="separator:aae61878d866a30350e082ce879e8a1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749de4e543cd8d7869f8c5bb483452ac"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES , typename mcont_t &gt; </td></tr>
<tr class="memitem:a749de4e543cd8d7869f8c5bb483452ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a749de4e543cd8d7869f8c5bb483452ac">count_mutations</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, const mcont_t &amp;mutations, SAMPLES &amp;&amp;samples, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;mcounts, std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;acounts)</td></tr>
<tr class="separator:a749de4e543cd8d7869f8c5bb483452ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d891ec4b65d5c1dbf028dcc14637bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a89d891ec4b65d5c1dbf028dcc14637bb">decapitate</a> (<a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, double time, bool remove_mutations)</td></tr>
<tr class="separator:a89d891ec4b65d5c1dbf028dcc14637bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df8628a86608fa402ff6430fc387408"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1df8628a86608fa402ff6430fc387408">operator==</a> (const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;a, const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;b)</td></tr>
<tr class="separator:a1df8628a86608fa402ff6430fc387408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7adfaff962a474c591150487bd909"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES &gt; </td></tr>
<tr class="memitem:a0de7adfaff962a474c591150487bd909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a0de7adfaff962a474c591150487bd909">generate_data_matrix</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, SAMPLES &amp;&amp;samples, const bool record_neutral, const bool record_selected, const bool skip_fixed, const double start, const double stop)</td></tr>
<tr class="separator:a0de7adfaff962a474c591150487bd909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1612dcf0c5cfa72f256a43ce9a53e96"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES &gt; </td></tr>
<tr class="memitem:ac1612dcf0c5cfa72f256a43ce9a53e96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ac1612dcf0c5cfa72f256a43ce9a53e96">generate_data_matrix</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, SAMPLES &amp;&amp;samples, const bool record_neutral, const bool record_selected, const bool skip_fixed)</td></tr>
<tr class="separator:ac1612dcf0c5cfa72f256a43ce9a53e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memTemplParams" colspan="2">template&lt;typename genetic_param_holder , typename mutation_handling_policy , typename poptype &gt; </td></tr>
<tr class="memitem:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8acb8ff641b41bc320a54cbcf9aa29a3">generate_offspring</a> (const gsl_rng *r, const std::pair&lt; std::size_t, std::size_t &gt; parents, const mutation_handling_policy &amp;mutation_policy, <a class="el" href="../../d2/df8/spatialts_8cc.html#af42af3a583005f9b1db56c61a5bdd18a">poptype</a> &amp;pop, genetic_param_holder &amp;genetics, typename <a class="el" href="../../df/d2f/classfwdpp_1_1poptypes_1_1diploid__population.html#a052c14db58db50aa14eaf931171f5e66">poptype::diploid_t</a> &amp;offspring)</td></tr>
<tr class="memdesc:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate offspring haploid_genomes and return breakpoints plus mutation keys.  <a href="#a8acb8ff641b41bc320a54cbcf9aa29a3">More...</a><br /></td></tr>
<tr class="separator:a8acb8ff641b41bc320a54cbcf9aa29a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116196377f3b3675bd12951dca7241f3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a116196377f3b3675bd12951dca7241f3">get_parent_ids</a> (const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> first_parental_index, const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> parent, const int did_swap)</td></tr>
<tr class="separator:a116196377f3b3675bd12951dca7241f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b95423c33fe838baeff2a99b184fcc"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES &gt; </td></tr>
<tr class="memitem:a37b95423c33fe838baeff2a99b184fcc"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, std::vector&lt; std::pair&lt; double, double &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37b95423c33fe838baeff2a99b184fcc">mark_multiple_roots</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, SAMPLES &amp;&amp;samples)</td></tr>
<tr class="memdesc:a37b95423c33fe838baeff2a99b184fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify root nodes in "marginal forests".  <a href="#a37b95423c33fe838baeff2a99b184fcc">More...</a><br /></td></tr>
<tr class="separator:a37b95423c33fe838baeff2a99b184fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af38d30f718a90af2ea98e81358c2c5"><td class="memTemplParams" colspan="2">template&lt;typename SAMPLES , typename rng , typename mfunction &gt; </td></tr>
<tr class="memitem:a8af38d30f718a90af2ea98e81358c2c5"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8af38d30f718a90af2ea98e81358c2c5">mutate_tables</a> (const rng &amp;r, const mfunction &amp;make_mutation, <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, SAMPLES &amp;&amp;samples, const double mu)</td></tr>
<tr class="memdesc:a8af38d30f718a90af2ea98e81358c2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a mutation scheme to add neutral mutations to a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>.  <a href="#a8af38d30f718a90af2ea98e81358c2c5">More...</a><br /></td></tr>
<tr class="separator:a8af38d30f718a90af2ea98e81358c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f05170560f56c1ac6316db842127ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a5f05170560f56c1ac6316db842127ba6">operator==</a> (const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;a, const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;b)</td></tr>
<tr class="separator:a5f05170560f56c1ac6316db842127ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dd878eb29e8e1b1fb09e0471f603f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a96dd878eb29e8e1b1fb09e0471f603f4">operator==</a> (const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;a, const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;b)</td></tr>
<tr class="separator:a96dd878eb29e8e1b1fb09e0471f603f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="memItemLeft" align="right" valign="top">flagged_mutation_queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4e7bf711e7bba2ce46c4cc64c313309e">make_mut_queue</a> (const std::vector&lt; std::uint32_t &gt; &amp;mcounts, const std::vector&lt; std::uint32_t &gt; &amp;counts_from_preserved_nodes)</td></tr>
<tr class="memdesc:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a mutation recycling queue for simulations with tree sequences.  <a href="#a4e7bf711e7bba2ce46c4cc64c313309e">More...</a><br /></td></tr>
<tr class="separator:a4e7bf711e7bba2ce46c4cc64c313309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac1cf69f783fd99ccd77b5ab998bb7"><td class="memItemLeft" align="right" valign="top">flagged_mutation_queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#abdac1cf69f783fd99ccd77b5ab998bb7">make_mut_queue</a> (const std::vector&lt; std::size_t &gt; &amp;preserved_mutation_indexes, const std::size_t num_mutations)</td></tr>
<tr class="memdesc:abdac1cf69f783fd99ccd77b5ab998bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a mutation recycling queue for simulations with tree sequences.  <a href="#abdac1cf69f783fd99ccd77b5ab998bb7">More...</a><br /></td></tr>
<tr class="separator:abdac1cf69f783fd99ccd77b5ab998bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31b6eea1568ee4866fc66bae4be31ef"><td class="memTemplParams" colspan="2">template&lt;typename poptype , typename mutation_count_container , typename preserve_selected_fixations , typename record_fixations &gt; </td></tr>
<tr class="memitem:af31b6eea1568ee4866fc66bae4be31ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af31b6eea1568ee4866fc66bae4be31ef">flag_mutations_for_recycling</a> (<a class="el" href="../../d2/df8/spatialts_8cc.html#af42af3a583005f9b1db56c61a5bdd18a">poptype</a> &amp;pop, mutation_count_container &amp;mcounts_from_preserved_nodes, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> twoN, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> generation, const preserve_selected_fixations preserve, const record_fixations record)</td></tr>
<tr class="separator:af31b6eea1568ee4866fc66bae4be31ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d8e70dbb7d9569b6eaaec8898a8e84"><td class="memTemplParams" colspan="2">template&lt;typename gcont_t , typename mcont_t , typename mutation_count_container &gt; </td></tr>
<tr class="memitem:ad5d8e70dbb7d9569b6eaaec8898a8e84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ad5d8e70dbb7d9569b6eaaec8898a8e84">remove_fixations_from_haploid_genomes</a> (gcont_t &amp;haploid_genomes, const mcont_t &amp;mutations, const mutation_count_container &amp;mcounts, const mutation_count_container &amp;mcounts_from_preserved_nodes, const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> twoN, const bool preserve_selected_fixations)</td></tr>
<tr class="memdesc:ad5d8e70dbb7d9569b6eaaec8898a8e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed fixed variants from haploid_genomes.  <a href="#ad5d8e70dbb7d9569b6eaaec8898a8e84">More...</a><br /></td></tr>
<tr class="separator:ad5d8e70dbb7d9569b6eaaec8898a8e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d915f7ae2ec362433d7ba793c72270"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ac2d915f7ae2ec362433d7ba793c72270">operator&lt;</a> (const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;a, const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;b)</td></tr>
<tr class="separator:ac2d915f7ae2ec362433d7ba793c72270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15de8fe006b0a740317f0c8d109fcea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ae15de8fe006b0a740317f0c8d109fcea">operator==</a> (const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;a, const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;b)</td></tr>
<tr class="separator:ae15de8fe006b0a740317f0c8d109fcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2101ddcc665e0077f8dc298425ac2d0f"><td class="memItemLeft" align="right" valign="top">site_vector::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a2101ddcc665e0077f8dc298425ac2d0f">end</a> (<a class="el" href="../../da/dfd/classfwdpp_1_1ts_1_1site__visitor.html">site_visitor</a> &amp;sv)</td></tr>
<tr class="separator:a2101ddcc665e0077f8dc298425ac2d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79321c58c8dec2eabbb073b689bf4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4e79321c58c8dec2eabbb073b689bf4e">operator==</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;a, const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;b)</td></tr>
<tr class="separator:a4e79321c58c8dec2eabbb073b689bf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab382753de993cedb4e1d14c152868446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab382753de993cedb4e1d14c152868446">operator!=</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;a, const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;b)</td></tr>
<tr class="separator:ab382753de993cedb4e1d14c152868446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d2e4ac41b0a71f39def87a0067409b"><td class="memTemplParams" colspan="2">template&lt;typename mcont_t &gt; </td></tr>
<tr class="memitem:aa9d2e4ac41b0a71f39def87a0067409b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aa9d2e4ac41b0a71f39def87a0067409b">record_mutations_infinite_sites</a> (const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u, const mcont_t &amp;mutations, const std::vector&lt; std::uint32_t &gt; &amp;new_mutation_keys, <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables)</td></tr>
<tr class="separator:aa9d2e4ac41b0a71f39def87a0067409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae056fadd81d2cbdeb96a417843db09"><td class="memTemplParams" colspan="2">template&lt;typename F , typename SAMPLES &gt; </td></tr>
<tr class="memitem:a8ae056fadd81d2cbdeb96a417843db09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8ae056fadd81d2cbdeb96a417843db09">visit_sites</a> (const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;tables, SAMPLES &amp;&amp;samples, const F &amp;f, const double from, const double to)</td></tr>
<tr class="memdesc:a8ae056fadd81d2cbdeb96a417843db09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to all sites in range [from, to)  <a href="#a8ae056fadd81d2cbdeb96a417843db09">More...</a><br /></td></tr>
<tr class="separator:a8ae056fadd81d2cbdeb96a417843db09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b7ce7325002612b10ddc46b831203b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a99b7ce7325002612b10ddc46b831203b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a99b7ce7325002612b10ddc46b831203b">process_children</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> n, bool left_to_right_traversal, const F &amp;f)</td></tr>
<tr class="memdesc:a99b7ce7325002612b10ddc46b831203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to children of node <em>n</em>.  <a href="#a99b7ce7325002612b10ddc46b831203b">More...</a><br /></td></tr>
<tr class="separator:a99b7ce7325002612b10ddc46b831203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab503ae0e38aeb913c55266665feb3152"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab503ae0e38aeb913c55266665feb3152">get_children</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> n, bool left_to_right_traversal)</td></tr>
<tr class="memdesc:ab503ae0e38aeb913c55266665feb3152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all children of a node.  <a href="#ab503ae0e38aeb913c55266665feb3152">More...</a><br /></td></tr>
<tr class="separator:ab503ae0e38aeb913c55266665feb3152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08036aaea8b364c31930ad309a6cc56b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08036aaea8b364c31930ad309a6cc56b">num_children</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> n)</td></tr>
<tr class="memdesc:a08036aaea8b364c31930ad309a6cc56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of children of a node.  <a href="#a08036aaea8b364c31930ad309a6cc56b">More...</a><br /></td></tr>
<tr class="separator:a08036aaea8b364c31930ad309a6cc56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071367c1dd58b17e5d2c50c87b52f4e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="../../d6/dd0/structfwdpp_1_1ts_1_1node__traversal__order.html">node_traversal_order</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a071367c1dd58b17e5d2c50c87b52f4e0">node_traversal_dispatch</a> (<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> root, <a class="el" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html">nodes_preorder</a>)</td></tr>
<tr class="memdesc:a071367c1dd58b17e5d2c50c87b52f4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles dependency injection of <a class="el" href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html" title="Preorder traversal of nodes for a node_iterator. ">node_traversal_preorder</a> into <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">node_iterator</a>.  <a href="#a071367c1dd58b17e5d2c50c87b52f4e0">More...</a><br /></td></tr>
<tr class="separator:a071367c1dd58b17e5d2c50c87b52f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7ef15ad73a3fae551eab0b7ade304c"><td class="memTemplParams" colspan="2">template&lt;typename ORDER , typename F &gt; </td></tr>
<tr class="memitem:a4f7ef15ad73a3fae551eab0b7ade304c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a4f7ef15ad73a3fae551eab0b7ade304c">process_nodes</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, ORDER order, const F &amp;f)</td></tr>
<tr class="separator:a4f7ef15ad73a3fae551eab0b7ade304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2965ace88c8d0b0563d3111ab088338f"><td class="memTemplParams" colspan="2">template&lt;typename ORDER , typename F &gt; </td></tr>
<tr class="memitem:a2965ace88c8d0b0563d3111ab088338f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a2965ace88c8d0b0563d3111ab088338f">process_nodes</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u, ORDER order, const F &amp;f)</td></tr>
<tr class="separator:a2965ace88c8d0b0563d3111ab088338f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac470f837dfaf69300aae5a677edf47c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ac470f837dfaf69300aae5a677edf47c9">num_nodes</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m)</td></tr>
<tr class="separator:ac470f837dfaf69300aae5a677edf47c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae775bd3654b36f17383b587526af1"><td class="memTemplParams" colspan="2">template&lt;typename ORDER &gt; </td></tr>
<tr class="memitem:affae775bd3654b36f17383b587526af1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#affae775bd3654b36f17383b587526af1">get_nodes</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, ORDER order)</td></tr>
<tr class="separator:affae775bd3654b36f17383b587526af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a932af939b5cae5bbcceec0c85e16e"><td class="memTemplParams" colspan="2">template&lt;typename ORDER &gt; </td></tr>
<tr class="memitem:a90a932af939b5cae5bbcceec0c85e16e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a90a932af939b5cae5bbcceec0c85e16e">get_nodes</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u, ORDER order)</td></tr>
<tr class="separator:a90a932af939b5cae5bbcceec0c85e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ca473e8d52b278e20a4edbbc711cf5"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a32ca473e8d52b278e20a4edbbc711cf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a32ca473e8d52b278e20a4edbbc711cf5">process_roots</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, const F &amp;f)</td></tr>
<tr class="memdesc:a32ca473e8d52b278e20a4edbbc711cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to all roots.  <a href="#a32ca473e8d52b278e20a4edbbc711cf5">More...</a><br /></td></tr>
<tr class="separator:a32ca473e8d52b278e20a4edbbc711cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba9096050c56e50c5216e50baf0520a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a9ba9096050c56e50c5216e50baf0520a">get_roots</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m)</td></tr>
<tr class="memdesc:a9ba9096050c56e50c5216e50baf0520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of all roots.  <a href="#a9ba9096050c56e50c5216e50baf0520a">More...</a><br /></td></tr>
<tr class="separator:a9ba9096050c56e50c5216e50baf0520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d54fd20651e657d980cc9aa908a22e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08d54fd20651e657d980cc9aa908a22e">num_roots</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m)</td></tr>
<tr class="memdesc:a08d54fd20651e657d980cc9aa908a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of roots.  <a href="#a08d54fd20651e657d980cc9aa908a22e">More...</a><br /></td></tr>
<tr class="separator:a08d54fd20651e657d980cc9aa908a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee9ab5b43e22baf42a72eab0fa8919a"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5ee9ab5b43e22baf42a72eab0fa8919a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a5ee9ab5b43e22baf42a72eab0fa8919a">process_samples</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a6529ade4ad161b3e22bb12bc537eafe2">convert_sample_index_to_nodes</a> convert, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u, const F &amp;f)</td></tr>
<tr class="memdesc:a5ee9ab5b43e22baf42a72eab0fa8919a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to the nodes descending from <em>u</em>.  <a href="#a5ee9ab5b43e22baf42a72eab0fa8919a">More...</a><br /></td></tr>
<tr class="separator:a5ee9ab5b43e22baf42a72eab0fa8919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aff21079382c8c2a200b678eb24a6c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a6aff21079382c8c2a200b678eb24a6c5">get_samples</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u)</td></tr>
<tr class="separator:a6aff21079382c8c2a200b678eb24a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280159065b7fd75ac05bbbb1a4ef5ec8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a280159065b7fd75ac05bbbb1a4ef5ec8">num_samples</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> u)</td></tr>
<tr class="memdesc:a280159065b7fd75ac05bbbb1a4ef5ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of samples descending from node <em>u</em> in <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> <em>m</em>.  <a href="#a280159065b7fd75ac05bbbb1a4ef5ec8">More...</a><br /></td></tr>
<tr class="separator:a280159065b7fd75ac05bbbb1a4ef5ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2426971517ba2ab54606a229827d35ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a2426971517ba2ab54606a229827d35ee">total_time</a> (const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;m, const std::vector&lt; <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &gt; &amp;nodes, bool scale_by_length)</td></tr>
<tr class="separator:a2426971517ba2ab54606a229827d35ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3b6e884129b83242fc56f14784a2a3d8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a3b6e884129b83242fc56f14784a2a3d8">TS_NULL_NODE</a> = -1</td></tr>
<tr class="memdesc:a3b6e884129b83242fc56f14784a2a3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index value of a NULL node.  <a href="#a3b6e884129b83242fc56f14784a2a3d8">More...</a><br /></td></tr>
<tr class="separator:a3b6e884129b83242fc56f14784a2a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca72a7b2f434364d247c827da7bae1f"><td class="memItemLeft" align="right" valign="top">constexpr std::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1ca72a7b2f434364d247c827da7bae1f">default_ancestral_state</a> = 0</td></tr>
<tr class="memdesc:a1ca72a7b2f434364d247c827da7bae1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convention for the ancestral state of a site.  <a href="#a1ca72a7b2f434364d247c827da7bae1f">More...</a><br /></td></tr>
<tr class="separator:a1ca72a7b2f434364d247c827da7bae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42592d55704647087b6539deb539b1b5"><td class="memItemLeft" align="right" valign="top">constexpr std::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a42592d55704647087b6539deb539b1b5">default_derived_state</a> = 1</td></tr>
<tr class="memdesc:a42592d55704647087b6539deb539b1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convention for the derived state of a site.  <a href="#a42592d55704647087b6539deb539b1b5">More...</a><br /></td></tr>
<tr class="separator:a42592d55704647087b6539deb539b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tree sequence <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2018-fu">[2]</a> support. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a6529ade4ad161b3e22bb12bc537eafe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6529ade4ad161b3e22bb12bc537eafe2">&#9670;&nbsp;</a></span>convert_sample_index_to_nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a6529ade4ad161b3e22bb12bc537eafe2">fwdpp::ts::convert_sample_index_to_nodes</a> = typedef <a class="el" href="../../dd/d53/structfwdpp_1_1strong__types_1_1named__type.html">strong_types::named_type</a>&lt;bool, <a class="el" href="../../d6/d8f/structfwdpp_1_1ts_1_1convert__sample__index__to__nodes__t.html">convert_sample_index_to_nodes_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Policy affecting behavior of <a class="el" href="../../d7/d13/classfwdpp_1_1ts_1_1samples__iterator.html" title="Faciliate traversal of the samples descending from a node. ">samples_iterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/da9/samples_8hpp_source.html#l00018">18</a> of file <a class="el" href="../../da/da9/samples_8hpp_source.html">samples.hpp</a>.</p>

</div>
</div>
<a id="aff3b5522130bcd6ca8feeb86276b0807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3b5522130bcd6ca8feeb86276b0807">&#9670;&nbsp;</a></span>edge_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#aff3b5522130bcd6ca8feeb86276b0807">fwdpp::ts::edge_vector</a> = typedef std::vector&lt;<a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An "edge table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dfa/table__types_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../d1/dfa/table__types_8hpp_source.html">table_types.hpp</a>.</p>

</div>
</div>
<a id="ab8aa2800d3ad3222f919e113cac33706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa2800d3ad3222f919e113cac33706">&#9670;&nbsp;</a></span>indexed_edge_container</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#ab8aa2800d3ad3222f919e113cac33706">fwdpp::ts::indexed_edge_container</a> = typedef std::vector&lt;<a class="el" href="../../d6/d1b/structfwdpp_1_1ts_1_1indexed__edge.html">indexed_edge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An index for an edge table. See <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kelleher2016-cb">[1]</a>, page 13</p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/db6/indexed__edge_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/db6/indexed__edge_8hpp_source.html">indexed_edge.hpp</a>.</p>

</div>
</div>
<a id="a37fa9d4b0f7f967c76a8d550102a7405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fa9d4b0f7f967c76a8d550102a7405">&#9670;&nbsp;</a></span>mutation_key_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37fa9d4b0f7f967c76a8d550102a7405">fwdpp::ts::mutation_key_vector</a> = typedef std::vector&lt;<a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "mutation table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dfa/table__types_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d1/dfa/table__types_8hpp_source.html">table_types.hpp</a>.</p>

</div>
</div>
<a id="a60c51e69b27f3e160eb62ea06591a2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c51e69b27f3e160eb62ea06591a2bb">&#9670;&nbsp;</a></span>node_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a60c51e69b27f3e160eb62ea06591a2bb">fwdpp::ts::node_vector</a> = typedef std::vector&lt;<a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "node table" </p><dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dfa/table__types_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../d1/dfa/table__types_8hpp_source.html">table_types.hpp</a>.</p>

</div>
</div>
<a id="a5a651f970d62175ab2a39a926ef384be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a651f970d62175ab2a39a926ef384be">&#9670;&nbsp;</a></span>site_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a5a651f970d62175ab2a39a926ef384be">fwdpp::ts::site_vector</a> = typedef std::vector&lt;<a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Site table. </p>
<dl class="section version"><dt>Version</dt><dd>0.8.0 Added to fwdpp </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dfa/table__types_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d1/dfa/table__types_8hpp_source.html">table_types.hpp</a>.</p>

</div>
</div>
<a id="af35a0875d0656933d78cc7840a662aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35a0875d0656933d78cc7840a662aa5">&#9670;&nbsp;</a></span>TS_NODE_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">fwdpp::ts::TS_NODE_INT</a> = typedef std::int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer type for node indexes. </p>

<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00013">13</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
<a id="a032633feb419313c220ff0fd18d3a594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032633feb419313c220ff0fd18d3a594">&#9670;&nbsp;</a></span>update_samples_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a032633feb419313c220ff0fd18d3a594">fwdpp::ts::update_samples_list</a> = typedef <a class="el" href="../../dd/d53/structfwdpp_1_1strong__types_1_1named__type.html">strong_types::named_type</a>&lt;bool, <a class="el" href="../../d1/dfc/structfwdpp_1_1ts_1_1update__samples__list__t.html">update_samples_list_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Policy dictating if a <a class="el" href="../../df/d8f/classfwdpp_1_1ts_1_1tree__visitor.html" title="Class that iterates over marginal trees. ">tree_visitor</a> updates sample lists. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/d55/tree__visitor_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d4/d55/tree__visitor_8hpp_source.html">tree_visitor.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae61878d866a30350e082ce879e8a1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae61878d866a30350e082ce879e8a1a4">&#9670;&nbsp;</a></span>count_mutations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES , typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::count_mutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a40">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html">count_mutations.hpp</a>.</p>

</div>
</div>
<a id="a749de4e543cd8d7869f8c5bb483452ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749de4e543cd8d7869f8c5bb483452ac">&#9670;&nbsp;</a></span>count_mutations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES , typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::count_mutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>acounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../dd/d23/count__mutations_8hpp_source.html">count_mutations.hpp</a>.</p>

</div>
</div>
<a id="a89d891ec4b65d5c1dbf028dcc14637bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d891ec4b65d5c1dbf028dcc14637bb">&#9670;&nbsp;</a></span>decapitate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::decapitate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\ brief "Decaptitate" a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">table_collection</a>.</p>
<p>Removes all nodes with time &lt;= <em>time</em> as well as corresponding entries from the edge table.</p>
<p>The table indexes are rebuilt.</p>
<p>This function has little use outside of testing. </p>

<p class="definition">Definition at line <a class="el" href="../../d7/d82/decapitate_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d7/d82/decapitate_8hpp_source.html">decapitate.hpp</a>.</p>

</div>
</div>
<a id="a2101ddcc665e0077f8dc298425ac2d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2101ddcc665e0077f8dc298425ac2d0f">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">site_vector::const_iterator fwdpp::ts::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dfd/classfwdpp_1_1ts_1_1site__visitor.html">site_visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d0/d27/site__visitor_8hpp_source.html#l00130">130</a> of file <a class="el" href="../../d0/d27/site__visitor_8hpp_source.html">site_visitor.hpp</a>.</p>

</div>
</div>
<a id="af31b6eea1568ee4866fc66bae4be31ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31b6eea1568ee4866fc66bae4be31ef">&#9670;&nbsp;</a></span>flag_mutations_for_recycling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poptype , typename mutation_count_container , typename preserve_selected_fixations , typename record_fixations &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::flag_mutations_for_recycling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/df8/spatialts_8cc.html#af42af3a583005f9b1db56c61a5bdd18a">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts_from_preserved_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a>&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a>&#160;</td>
          <td class="paramname"><em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const preserve_selected_fixations&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const record_fixations&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark mutations for recycling.</p>
<p>This function should be called immediately after simplification and mutation counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pop</td><td>A mutation container </td></tr>
    <tr><td class="paramname">mcounts_from_preserved_nodes</td><td>A container recording the counts of each mutation in ancient samples </td></tr>
    <tr><td class="paramname">twoN</td><td>Twice the current population size </td></tr>
    <tr><td class="paramname">generation</td><td>Current generation/time step in the simulation </td></tr>
    <tr><td class="paramname">preserve</td><td>Policy for handling selected fixations. See below. </td></tr>
    <tr><td class="paramname">record</td><td>Policy for recording fixation events. See below.</td></tr>
  </table>
  </dd>
</dl>
<p>A mutation is marked for recycling if one of the following conditions holds:</p><ol type="1">
<li>The sum of <em>pop.mcounts</em> and <em>mcounts_from_preserved_nodes</em> is zero.</li>
<li><em>pop.mcounts</em> == <em>twoN</em>, mcounts_from_preserved_nodes is zero, and <em>record</em> is std::false_type or the mutation is neutral.</li>
</ol>
<p>Condition 1 refers to extinct mutations and condition 2 refers to fixations.</p>
<p>When <em>preserve</em> is std::true_type, selected fixations are retained in the population. We do this because simulations of phenotypes (as opposed to relative fitness) require tracking the contribution of fixation to trait values.</p>
<p>All variants matching the above criteria have their record in <em>pop.mcounts</em> set to zero and their position is removed from <em>pop.mut_lookup</em>. Further, the mutation's position in <em>pop.mutations</em> is set to std::numeric_limits&lt;double&gt;::max(), to signify an "invalid" mutation.</p>
<p>If <em>record</em> is std::false_type, no fixation recording takes place. However, if <em>record</em> is std::true_type, a record is entered into <em>pop.fixations</em> and <em>pop.fixation_times</em>. If <em>preserve</em> is also std::true_type, the recording is slightly more expensive because we have to guard against repeated recording. For this case, the fixations and fixation times containers in <em>pop</em> are kept sorted by fixation position.</p>
<p>An advanced use of this function is to create branchless code with respect to fixation handling. One can generate a closure wrapping this function with the desired values of <em>preserve</em> and <em>record</em> at the start of a simulation, thus avoiding a bunch of "if" statements prior to each call.</p>
<dl class="section note"><dt>Note</dt><dd>There are several caveats to fixation recording (<em>record</em> == std::true_type). First, it is only as accurate as the time steps between simplifications is small. <em>pop</em> will only contain exact fixation times if simplification occurs every generation. The second limitation is that it will not give correct results if ancient samples are being tracked in a simulation. This has to do with a "todo" item for this function described below. Thus, fixation recording with this function should be considered limited to the case of regular simplification and no ancient sample preservation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <em>preserve</em> argument needs to be consistent with the desired behavior of ts::remove_fixations_from_gametes.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.1 Updated to change recycled mutation positions to max value of a double. Refactor API to take compile-time policies for fixation handling.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">Improve treatment of fixations by allowing for variants fixed in alive AND ancient samples to be flagged. </p>
<p class="enddd">Return a recycling queue? </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00238">238</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="a0de7adfaff962a474c591150487bd909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7adfaff962a474c591150487bd909">&#9670;&nbsp;</a></span>generate_data_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a> fwdpp::ts::generate_data_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_neutral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>skip_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000002">Todo:</a></b></dt><dd>Document </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.1 Change behavior to skip sites fixed in the sample </dd>
<dd>
0.7.4 Add [start, stop) arguments. Add option to skip fixed variants. </dd>
<dd>
0.8.0 No longer requires mutation vector. Function body re-implemented. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html">generate_data_matrix.hpp</a>.</p>

</div>
</div>
<a id="ac1612dcf0c5cfa72f256a43ce9a53e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1612dcf0c5cfa72f256a43ce9a53e96">&#9670;&nbsp;</a></span>generate_data_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d3a/structfwdpp_1_1data__matrix.html">data_matrix</a> fwdpp::ts::generate_data_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_neutral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>record_selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>skip_fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../df/d24/generate__data__matrix_8hpp_source.html">generate_data_matrix.hpp</a>.</p>

</div>
</div>
<a id="a8acb8ff641b41bc320a54cbcf9aa29a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acb8ff641b41bc320a54cbcf9aa29a3">&#9670;&nbsp;</a></span>generate_offspring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename genetic_param_holder , typename mutation_handling_policy , typename poptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>&gt; fwdpp::ts::generate_offspring </td>
          <td>(</td>
          <td class="paramtype">const gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::size_t, std::size_t &gt;&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_handling_policy &amp;&#160;</td>
          <td class="paramname"><em>mutation_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/df8/spatialts_8cc.html#af42af3a583005f9b1db56c61a5bdd18a">poptype</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genetic_param_holder &amp;&#160;</td>
          <td class="paramname"><em>genetics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="../../df/d2f/classfwdpp_1_1poptypes_1_1diploid__population.html#a052c14db58db50aa14eaf931171f5e66">poptype::diploid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>offspring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate offspring haploid_genomes and return breakpoints plus mutation keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Random number generator </td></tr>
    <tr><td class="paramname">parents</td><td>Indexes of the offspring parents in <em>pop</em> </td></tr>
    <tr><td class="paramname">mutation_policy</td><td>Either <a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">all_mutations</a> or <a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">selected_variants_only</a>. See below. </td></tr>
    <tr><td class="paramname">pop</td><td><a class="el" href="../../df/d2f/classfwdpp_1_1poptypes_1_1diploid__population.html" title="Abstraction of what is needed to simulate a single-locus population. ">fwdpp::poptypes::diploid_population</a> </td></tr>
    <tr><td class="paramname">genetics</td><td>A duck type of <a class="el" href="../../da/db0/structfwdpp_1_1genetic__parameters.html" title="Hold types for genetic operations. ">fwdpp::genetic_parameters</a>. </td></tr>
    <tr><td class="paramname">offspring</td><td>The offspring for which we will generate haploid_genomes.</td></tr>
  </table>
  </dd>
</dl>
<p>The final three parameters will be modified.</p>
<dl class="section return"><dt>Returns</dt><dd>A pair of <a class="el" href="../../d2/d54/structfwdpp_1_1ts_1_1mut__rec__intermediates.html">mut_rec_intermediates</a>, corresponding to what is passed on from each parent.</dd></dl>
<p>The operations are dispatched out to functions based on the population type. These functions make calls to <a class="el" href="../../dd/d84/namespacefwdpp.html#a305775e119176134316d95cf9bddc818">fwdpp::mutate_recombine</a>.</p>
<p>The parameter <em>mutation_policy</em> governs what types of mutations are entered into the haploid_genomes of <em>offspring</em>. If the policy is <a class="el" href="../../d8/d48/structfwdpp_1_1ts_1_1all__mutations.html">fwdpp::ts::all_mutations</a>, then neutral and selected variants are placed in an offspring's haploid_genomes. If the policy is <a class="el" href="../../de/de4/structfwdpp_1_1ts_1_1selected__variants__only.html">fwdpp::ts::selected_variants_only</a>, then only selected mutations are placed into the haploid_genomes. Regardless of the policy, ALL mutations are contained in the return value, with the idea that the caller will record them into a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function type genetic_param_holder::generate_mutations must return std::vector&lt;fwdpp::uint_t&gt;, with the values reflecting the locations of new mutations on <em>pop.mutations</em>. Further, this function must already bind any relevant mutation rates (as this generate_offspring does not accept them as arguments).</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.4 Added to <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html" title="Tree sequence  support. ">fwdpp::ts</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d9c/generate__offspring_8hpp_source.html#l00185">185</a> of file <a class="el" href="../../df/d9c/generate__offspring_8hpp_source.html">generate_offspring.hpp</a>.</p>

</div>
</div>
<a id="ab503ae0e38aeb913c55266665feb3152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab503ae0e38aeb913c55266665feb3152">&#9670;&nbsp;</a></span>get_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right_traversal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all children of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a> </td></tr>
    <tr><td class="paramname">n</td><td>Index a <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a> </td></tr>
    <tr><td class="paramname">left_to_right_traversal.</td><td>If <code>true</code>, traverse children left-to-right. Else, the opposite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;fwdpp::ts::TS_NODE_INT&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d27/children_8hpp_source.html#l00101">101</a> of file <a class="el" href="../../d4/d27/children_8hpp_source.html">children.hpp</a>.</p>

</div>
</div>
<a id="affae775bd3654b36f17383b587526af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae775bd3654b36f17383b587526af1">&#9670;&nbsp;</a></span>get_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ORDER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORDER&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a vector of all nodes in the tree <em>m</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> </td></tr>
    <tr><td class="paramname">order</td><td>A dispatch tag specifying the node traversal roder </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d38/nodes_8hpp_source.html#l00176">176</a> of file <a class="el" href="../../de/d38/nodes_8hpp_source.html">nodes.hpp</a>.</p>

</div>
</div>
<a id="a90a932af939b5cae5bbcceec0c85e16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a932af939b5cae5bbcceec0c85e16e">&#9670;&nbsp;</a></span>get_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ORDER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORDER&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a vector of all nodes in the subtree of <em>m</em> whose root is <em>u</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> </td></tr>
    <tr><td class="paramname">u</td><td>A node in <em>m</em> </td></tr>
    <tr><td class="paramname">order</td><td>A dispatch tag specifying the node traversal roder </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d38/nodes_8hpp_source.html#l00190">190</a> of file <a class="el" href="../../de/d38/nodes_8hpp_source.html">nodes.hpp</a>.</p>

</div>
</div>
<a id="a116196377f3b3675bd12951dca7241f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116196377f3b3675bd12951dca7241f3">&#9670;&nbsp;</a></span>get_parent_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_parent_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>first_parental_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>did_swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the index of a parent into the two node IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_parental_index</td><td>First index of possible parents for offspring </td></tr>
    <tr><td class="paramname">parent</td><td>Index of parent in the population </td></tr>
    <tr><td class="paramname">did_swap</td><td>This is the "Mendel" step.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is trivial in implementation and is easily replaced if a more complex set of rules are needed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a32">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d9/dbe/get__parent__ids_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d9/dbe/get__parent__ids_8hpp_source.html">get_parent_ids.hpp</a>.</p>

</div>
</div>
<a id="a9ba9096050c56e50c5216e50baf0520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba9096050c56e50c5216e50baf0520a">&#9670;&nbsp;</a></span>get_roots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of all roots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A Fwdpp::ts::marginal_tree </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d0e/roots_8hpp_source.html#l00081">81</a> of file <a class="el" href="../../d9/d0e/roots_8hpp_source.html">roots.hpp</a>.</p>

</div>
</div>
<a id="a6aff21079382c8c2a200b678eb24a6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aff21079382c8c2a200b678eb24a6c5">&#9670;&nbsp;</a></span>get_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&gt; fwdpp::ts::get_samples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector of samples descending from node <em>u</em> in <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> <em>m</em>. The return value contains node ids (as opposed to sample indexes) </p>

<p class="definition">Definition at line <a class="el" href="../../da/da9/samples_8hpp_source.html#l00132">132</a> of file <a class="el" href="../../da/da9/samples_8hpp_source.html">samples.hpp</a>.</p>

</div>
</div>
<a id="a4e7bf711e7bba2ce46c4cc64c313309e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7bf711e7bba2ce46c4cc64c313309e">&#9670;&nbsp;</a></span>make_mut_queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flagged_mutation_queue fwdpp::ts::make_mut_queue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts_from_preserved_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a mutation recycling queue for simulations with tree sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcounts</td><td>Contribution of extant nodes to mutation counts </td></tr>
    <tr><td class="paramname">counts_from_preserved_nodes</td><td>Contribution of extinct nodes to mutation counts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to fwdpp</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>flagged_mutation_queue </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d4/d99/custom_mutation_8cc-example.html#a21">custom_mutation.cc</a>, <a class="el" href="../../da/db8/juvenile_migration_8cc-example.html#a13">juvenile_migration.cc</a>, and <a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a28">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="abdac1cf69f783fd99ccd77b5ab998bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdac1cf69f783fd99ccd77b5ab998bb7">&#9670;&nbsp;</a></span>make_mut_queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flagged_mutation_queue fwdpp::ts::make_mut_queue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>preserved_mutation_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>num_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a mutation recycling queue for simulations with tree sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserved_mutation_indexes</td><td>Vector of preserved mutation indexes returned by simplification </td></tr>
    <tr><td class="paramname">num_mutations</td><td>The total number of mutations currently allocated in the population</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flagged_mutation_queue</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.3 Added to fwdpp</dd></dl>
<p>This overload may be preferable to the other when the following conditions apply:</p><ol type="1">
<li>Mutation counts in the entire simulation are not of interest during the simulation.</li>
<li>There is no need/wish to remove fixations from the gametes/tables during the simulation.</li>
<li>There are large numbers of ancient samples being recorded.</li>
</ol>
<p>The first two conditions are required for correct results. The third condition is optional, but big speedups will be seen for that case.</p>
<p>This function generates a recycling queue using a fast O(N) algorithm. This, it will outperform the other overload based on tree traversal when the number of trees is very large, as is the case when large numbers of ancestral samples are registered during a simulation. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/d3f/recycling_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d6/d3f/recycling_8hpp_source.html">recycling.hpp</a>.</p>

</div>
</div>
<a id="a37b95423c33fe838baeff2a99b184fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b95423c33fe838baeff2a99b184fcc">&#9670;&nbsp;</a></span>mark_multiple_roots()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>, std::vector&lt;std::pair&lt;double, double&gt; &gt; &gt; fwdpp::ts::mark_multiple_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify root nodes in "marginal forests". </p>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.4 Refactored to use root tracking method </dd>
<dd>
0.8.0 Refactored to use <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a08d54fd20651e657d980cc9aa908a22e" title="Return number of roots. ">ts::num_roots</a> and <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a32ca473e8d52b278e20a4edbbc711cf5" title="Apply a function to all roots. ">ts::process_roots</a></dd></dl>
<p>See <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a8af38d30f718a90af2ea98e81358c2c5" title="Apply a mutation scheme to add neutral mutations to a fwdpp::ts::table_collection. ">fwdpp::ts::mutate_tables</a> for discussion. </p>

<p class="definition">Definition at line <a class="el" href="../../dc/d57/mark__multiple__roots_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../dc/d57/mark__multiple__roots_8hpp_source.html">mark_multiple_roots.hpp</a>.</p>

</div>
</div>
<a id="a8af38d30f718a90af2ea98e81358c2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af38d30f718a90af2ea98e81358c2c5">&#9670;&nbsp;</a></span>mutate_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SAMPLES , typename rng , typename mfunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned fwdpp::ts::mutate_tables </td>
          <td>(</td>
          <td class="paramtype">const rng &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfunction &amp;&#160;</td>
          <td class="paramname"><em>make_mutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a mutation scheme to add neutral mutations to a <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="../../dd/d61/classfwdpp_1_1GSLrng__t.html" title="A wrapper around gsl_rng * objects. ">fwdpp::GSLrng_t</a> </td></tr>
    <tr><td class="paramname">make_mutation</td><td>A mutation function. See below. </td></tr>
    <tr><td class="paramname">tables</td><td>A <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">fwdpp::ts::table_collection</a> </td></tr>
    <tr><td class="paramname">samples</td><td>A list of sample nodes corresponding to "currently-alive" nodes </td></tr>
    <tr><td class="paramname">mu</td><td>Mutation rate (per gamete, per generation)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>0.7.0 Added to library </dd>
<dd>
0.7.2 Return immediately if mutation rate is not &gt; 0</dd></dl>
<p>This function uses the edge_table to apply mutations to all parent/child connections. The mutations should be neutral, although that requirement is not enforced. (It simply makes little sense to apply selected mutations to the entire edge table post-hoc.)</p>
<p>The result of this function is to populate <em>tables.mutation_table</em> with neutral variants.</p>
<p>The parameter <em>make_mutation</em> is a function that must conform to std::function&lt;new_variant_record(double, double, fwdpp::uint_t)&gt;. The three arguments are interpreted as "left", "right", and "time". The function's return value allows us to properly update the site and mutation tables in <em>tables</em>. The new mutation must have a position on the half-open interval [left, right). The "time" parameger represents the generation when the mutation arose and will be uniformly assigned between the parental birth time and that of the child. This mutation's origin time will be on the half-open interval (parental birth time, child birth time].</p>
<p>The preceding paragraph implies that <em>make_mutation</em> is repsonsible for required operations related to mutation recycling, etc.. The lambda "neutral_variant_maker" in the example program wfts.cc will probably be of help here.</p>
<p>It is common that, at the end of a forward-time simulation, that not all trees are completely coalesced. This happens because the distribution on the time to MRCA has very high variance and, due to recombination, some fraction of trees will not be coalesced after, say, 10N generations of evolving a single Wright-Fisher deme. Further, the simlification algorithm will "push" the most ancient nodes on these "marginal forests" forwards in time to the most recent ancestral node of each tree in the forest. Thus, naively mutating the edge table will place too few mutations on these parts of the genome. This function corrects for the presence of marginal forests, as described below.</p>
<p>The <em>samples</em> list is used to identify "marginal forests", meaning marginal trees that are not completely coalesced. (The finding is done via a call to <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a37b95423c33fe838baeff2a99b184fcc" title="Identify root nodes in &quot;marginal forests&quot;. ">fwdpp::ts::mark_multiple_roots</a>.) The MRCA nodes on trees in marginal forests have additional mutations on them, representing evolution from time point zero (the beginning of the simulation) to the MRCA node's time.</p>
<p>Note that two alternatives exist that will render the treatment of marginal forests unnecessary:</p><ol type="1">
<li>Simulate for longer. For example, CDF of TMRCA under Wright-Fisher is quite close to 1 at ~20N generations. Thus, simulating longer means that fewer and fewer marginal trees will be forests.</li>
<li>Start the simulation with an existing, completely-coalesced, tree sequence. As far as fwdpp is concerned, this is left as an "exercise for the reader" at the moment. </li>
</ol>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a39">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../db/d16/mutate__tables_8hpp_source.html#l00018">18</a> of file <a class="el" href="../../db/d16/mutate__tables_8hpp_source.html">mutate_tables.hpp</a>.</p>

</div>
</div>
<a id="a071367c1dd58b17e5d2c50c87b52f4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071367c1dd58b17e5d2c50c87b52f4e0">&#9670;&nbsp;</a></span>node_traversal_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="../../d6/dd0/structfwdpp_1_1ts_1_1node__traversal__order.html">node_traversal_order</a>&gt; fwdpp::ts::node_traversal_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/structfwdpp_1_1ts_1_1nodes__preorder.html">nodes_preorder</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles dependency injection of <a class="el" href="../../dc/dcd/classfwdpp_1_1ts_1_1node__traversal__preorder.html" title="Preorder traversal of nodes for a node_iterator. ">node_traversal_preorder</a> into <a class="el" href="../../d2/d43/classfwdpp_1_1ts_1_1node__iterator.html" title="Traverse nodes in a marginal_tree. ">node_iterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/d0c/node__traversal__preorder_8hpp_source.html#l00063">63</a> of file <a class="el" href="../../d4/d0c/node__traversal__preorder_8hpp_source.html">node_traversal_preorder.hpp</a>.</p>

</div>
</div>
<a id="a08036aaea8b364c31930ad309a6cc56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08036aaea8b364c31930ad309a6cc56b">&#9670;&nbsp;</a></span>num_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fwdpp::ts::num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of children of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a> </td></tr>
    <tr><td class="paramname">n</td><td>Index a <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d27/children_8hpp_source.html#l00116">116</a> of file <a class="el" href="../../d4/d27/children_8hpp_source.html">children.hpp</a>.</p>

</div>
</div>
<a id="ac470f837dfaf69300aae5a677edf47c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac470f837dfaf69300aae5a677edf47c9">&#9670;&nbsp;</a></span>num_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fwdpp::ts::num_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of nodes in <em>m</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d38/nodes_8hpp_source.html#l00164">164</a> of file <a class="el" href="../../de/d38/nodes_8hpp_source.html">nodes.hpp</a>.</p>

</div>
</div>
<a id="a08d54fd20651e657d980cc9aa908a22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d54fd20651e657d980cc9aa908a22e">&#9670;&nbsp;</a></span>num_roots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fwdpp::ts::num_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of roots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A Fwdpp::ts::marginal_tree </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d0e/roots_8hpp_source.html#l00091">91</a> of file <a class="el" href="../../d9/d0e/roots_8hpp_source.html">roots.hpp</a>.</p>

</div>
</div>
<a id="a280159065b7fd75ac05bbbb1a4ef5ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280159065b7fd75ac05bbbb1a4ef5ec8">&#9670;&nbsp;</a></span>num_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fwdpp::ts::num_samples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of samples descending from node <em>u</em> in <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> <em>m</em>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/da9/samples_8hpp_source.html#l00143">143</a> of file <a class="el" href="../../da/da9/samples_8hpp_source.html">samples.hpp</a>.</p>

</div>
</div>
<a id="ab382753de993cedb4e1d14c152868446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab382753de993cedb4e1d14c152868446">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00519">519</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="ac2d915f7ae2ec362433d7ba793c72270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d915f7ae2ec362433d7ba793c72270">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/de0/site_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../db/de0/site_8hpp_source.html">site.hpp</a>.</p>

</div>
</div>
<a id="ae15de8fe006b0a740317f0c8d109fcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15de8fe006b0a740317f0c8d109fcea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">site</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/de0/site_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../db/de0/site_8hpp_source.html">site.hpp</a>.</p>

</div>
</div>
<a id="a1df8628a86608fa402ff6430fc387408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df8628a86608fa402ff6430fc387408">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d25/structfwdpp_1_1ts_1_1edge.html">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d4/ddf/edge_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d4/ddf/edge_8hpp_source.html">edge.hpp</a>.</p>

</div>
</div>
<a id="a96dd878eb29e8e1b1fb09e0471f603f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dd878eb29e8e1b1fb09e0471f603f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d09/node_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d3/d09/node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a5f05170560f56c1ac6316db842127ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f05170560f56c1ac6316db842127ba6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d5e/structfwdpp_1_1ts_1_1mutation__record.html">mutation_record</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d1/d31/mutation__record_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d1/d31/mutation__record_8hpp_source.html">mutation_record.hpp</a>.</p>

</div>
</div>
<a id="a4e79321c58c8dec2eabbb073b689bf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79321c58c8dec2eabbb073b689bf4e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fwdpp::ts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00508">508</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="a99b7ce7325002612b10ddc46b831203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b7ce7325002612b10ddc46b831203b">&#9670;&nbsp;</a></span>process_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::process_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right_traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to children of node <em>n</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a> </td></tr>
    <tr><td class="paramname">n</td><td>Index a <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a> </td></tr>
    <tr><td class="paramname">left_to_right_traversal.</td><td>If <code>true</code>, traverse children left-to-right. Else, the opposite. </td></tr>
    <tr><td class="paramname">f</td><td>A function equivalent to void (*process_child)(TS_NODE_INT) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d27/children_8hpp_source.html#l00086">86</a> of file <a class="el" href="../../d4/d27/children_8hpp_source.html">children.hpp</a>.</p>

</div>
</div>
<a id="a4f7ef15ad73a3fae551eab0b7ade304c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7ef15ad73a3fae551eab0b7ade304c">&#9670;&nbsp;</a></span>process_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ORDER , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::process_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORDER&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to all nodes in the tree <em>m</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> </td></tr>
    <tr><td class="paramname">order</td><td>A dispatch tag specifying the node traversal roder </td></tr>
    <tr><td class="paramname">f</td><td>A function behaving as void(*process_node)(TS_NODE_INT) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d38/nodes_8hpp_source.html#l00135">135</a> of file <a class="el" href="../../de/d38/nodes_8hpp_source.html">nodes.hpp</a>.</p>

</div>
</div>
<a id="a2965ace88c8d0b0563d3111ab088338f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2965ace88c8d0b0563d3111ab088338f">&#9670;&nbsp;</a></span>process_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ORDER , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::process_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORDER&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to all nodes in the subtree whose root is <em>u</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">marginal_tree</a> </td></tr>
    <tr><td class="paramname">u</td><td>A node id in <em>m</em> </td></tr>
    <tr><td class="paramname">order</td><td>A dispatch tag specifying the node traversal roder </td></tr>
    <tr><td class="paramname">f</td><td>A function behaving as void(*process_node)(TS_NODE_INT) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d38/nodes_8hpp_source.html#l00149">149</a> of file <a class="el" href="../../de/d38/nodes_8hpp_source.html">nodes.hpp</a>.</p>

</div>
</div>
<a id="a32ca473e8d52b278e20a4edbbc711cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ca473e8d52b278e20a4edbbc711cf5">&#9670;&nbsp;</a></span>process_roots()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::process_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to all roots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A Fwdpp::ts::marginal_tree </td></tr>
    <tr><td class="paramname">f</td><td>A function equivalent to void(*process_root)(TS_NODE_INT) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d0e/roots_8hpp_source.html#l00069">69</a> of file <a class="el" href="../../d9/d0e/roots_8hpp_source.html">roots.hpp</a>.</p>

</div>
</div>
<a id="a5ee9ab5b43e22baf42a72eab0fa8919a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee9ab5b43e22baf42a72eab0fa8919a">&#9670;&nbsp;</a></span>process_samples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::process_samples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#a6529ade4ad161b3e22bb12bc537eafe2">convert_sample_index_to_nodes</a>&#160;</td>
          <td class="paramname"><em>convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to the nodes descending from <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html" title="A non-recombining tree. ">fwdpp::ts::marginal_tree</a> </td></tr>
    <tr><td class="paramname">convert</td><td>whether to iterate over sample nodes or sample list indexes </td></tr>
    <tr><td class="paramname">u</td><td>Index a <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">fwdpp::ts::node</a> </td></tr>
    <tr><td class="paramname">f</td><td>A function equivalent to void (*foo)(TS_NODE_INT) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/da9/samples_8hpp_source.html#l00116">116</a> of file <a class="el" href="../../da/da9/samples_8hpp_source.html">samples.hpp</a>.</p>

</div>
</div>
<a id="aa9d2e4ac41b0a71f39def87a0067409b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2e4ac41b0a71f39def87a0067409b">&#9670;&nbsp;</a></span>record_mutations_infinite_sites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename mcont_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::record_mutations_infinite_sites </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_mutation_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section version"><dt>Version</dt><dd>Added in 0.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d70/table__collection_8hpp_source.html#l00526">526</a> of file <a class="el" href="../../d3/d70/table__collection_8hpp_source.html">table_collection.hpp</a>.</p>

</div>
</div>
<a id="ad5d8e70dbb7d9569b6eaaec8898a8e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d8e70dbb7d9569b6eaaec8898a8e84">&#9670;&nbsp;</a></span>remove_fixations_from_haploid_genomes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename gcont_t , typename mcont_t , typename mutation_count_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::remove_fixations_from_haploid_genomes </td>
          <td>(</td>
          <td class="paramtype">gcont_t &amp;&#160;</td>
          <td class="paramname"><em>haploid_genomes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mcont_t &amp;&#160;</td>
          <td class="paramname"><em>mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutation_count_container &amp;&#160;</td>
          <td class="paramname"><em>mcounts_from_preserved_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">fwdpp::uint_t</a>&#160;</td>
          <td class="paramname"><em>twoN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserve_selected_fixations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed fixed variants from haploid_genomes. </p>
<p>This function should be called immediately after simplification and mutation counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haploid_genomes</td><td>A haploid_genome container </td></tr>
    <tr><td class="paramname">mutations</td><td>A mutation container </td></tr>
    <tr><td class="paramname">mcounts</td><td>A container stating how many times each element in <em>mutations</em> is present in the currently-alive population </td></tr>
    <tr><td class="paramname">mcounts_from_preserved_nodes</td><td>A container recording the counts of each mutation in ancient samples </td></tr>
    <tr><td class="paramname">twoN</td><td>Twice the current population size </td></tr>
    <tr><td class="paramname">preserve_selected_fixations</td><td>If true, do not mark selected fixations for recycling.</td></tr>
  </table>
  </dd>
</dl>
<p>A mutation is removed from a haploid_genome if one of the following conditions holds:</p><ol type="1">
<li>The sum of <em>mcounts</em> and <em>mcounts_from_preserved_nodes</em> is zero.</li>
<li><em>mcounts</em> == <em>twoN</em>, mcounts_from_preserved_nodes is zero, and <em>preserve_selected_fixations</em> is false or the mutation is neutral.</li>
</ol>
<p>When <em>preserve_selected_fixations</em> is true, selected fixations are retained in the population. We do this because simulations of phenotypes (as opposed to relative fitness) require tracking the contribution of fixation to trait values.</p>
<dl class="section note"><dt>Note</dt><dd>When simulating a trait and never simulating neutral mutations, the most efficient thing is to skip calling this function entirely.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The value passed to <em>preserve_selected_fixations</em> needs to be coordinated with the <em>preserve</em> argument of flag_mutations_for_recycling.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo:</a></b></dt><dd>Improve treatment of fixations by allowing for variants fixed in alive AND ancient samples to be detected. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/dc7/remove__fixations__from__gametes_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../da/dc7/remove__fixations__from__gametes_8hpp_source.html">remove_fixations_from_gametes.hpp</a>.</p>

</div>
</div>
<a id="a2426971517ba2ab54606a229827d35ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2426971517ba2ab54606a229827d35ee">&#9670;&nbsp;</a></span>total_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fwdpp::ts::total_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d6a/classfwdpp_1_1ts_1_1marginal__tree.html">marginal_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d5/d4f/structfwdpp_1_1ts_1_1node.html">node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scale_by_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dd/d37/statistics_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../dd/d37/statistics_8hpp_source.html">statistics.hpp</a>.</p>

</div>
</div>
<a id="a8ae056fadd81d2cbdeb96a417843db09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae056fadd81d2cbdeb96a417843db09">&#9670;&nbsp;</a></span>visit_sites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename SAMPLES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fwdpp::ts::visit_sites </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html">table_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAMPLES &amp;&amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to all sites in range [from, to) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td>A <a class="el" href="../../d7/de8/structfwdpp_1_1ts_1_1table__collection.html" title="A collection of tables for a single simulation. ">ts::table_collection</a> </td></tr>
    <tr><td class="paramname">samples</td><td>A list of samples </td></tr>
    <tr><td class="paramname">f</td><td>A function. See below </td></tr>
    <tr><td class="paramname">from</td><td>Start of range (inclusive) </td></tr>
    <tr><td class="paramname">to</td><td>End of range (exclusive)</td></tr>
  </table>
  </dd>
</dl>
<p>The type of <em>f</em> must be equavalent to:</p>
<div class="fragment"><div class="line">std::function&lt;void(<span class="keyword">const</span> ts::marginal_tree&amp;, <span class="keyword">const</span> ts::site&amp;,</div><div class="line">    mutation_key_vector::const_iterator, mutation_key_vector::const_iterator)&gt;</div></div><!-- fragment --><p>The last two iterators define the range of mutations in  correpsonding to the <a class="el" href="../../d2/d6e/structfwdpp_1_1ts_1_1site.html">ts::site</a> object passed in. The range is defined following standard C++ conventions for bidirectional iterators from a vector. </p><dl class="section version"><dt>Version</dt><dd>0.8.0 Added to library </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/db9/visit__sites_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../dd/db9/visit__sites_8hpp_source.html">visit_sites.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1ca72a7b2f434364d247c827da7bae1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca72a7b2f434364d247c827da7bae1f">&#9670;&nbsp;</a></span>default_ancestral_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int8_t fwdpp::ts::default_ancestral_state = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convention for the ancestral state of a site. </p>

<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
<a id="a42592d55704647087b6539deb539b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42592d55704647087b6539deb539b1b5">&#9670;&nbsp;</a></span>default_derived_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int8_t fwdpp::ts::default_derived_state = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convention for the derived state of a site. </p>

<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
<a id="a3b6e884129b83242fc56f14784a2a3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6e884129b83242fc56f14784a2a3d8">&#9670;&nbsp;</a></span>TS_NULL_NODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d8/d31/namespacefwdpp_1_1ts.html#af35a0875d0656933d78cc7840a662aa5">TS_NODE_INT</a> fwdpp::ts::TS_NULL_NODE = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index value of a NULL node. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d0a/spatialts_8cc-example.html#a31">spatialts.cc</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../d1/dc9/definitions_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d1/dc9/definitions_8hpp_source.html">definitions.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
