<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: Overview of fwdpp features</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Overview of fwdpp features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document is a quick tour of <b>fwdpp</b>'s features. It also points out what is missing from the library that may or may not be addressed in the future.</p>
<p>The document assumes a working knowledge of C++11 and skips details, such as class constructor implementation, that are C++11 issues rather than <b>fwdpp</b> issues.</p>
<p>Sub-sections named "aside" may be skipped&ndash;they contain some technical details that hopefully address questions that proficient C++ programmers may have.</p>
<h2>Library headers</h2>
<p>The library is header-only, meaning that there is no runtime library to link to. Rather, the vast majority of library code is implemented as generic templates.</p>
<p>There are two main headers to be aware of:</p>
<div class="fragment"><div class="line"><span class="comment">//This includes the low-level library:</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/df8/diploid_8hh.html">fwdpp/diploid.hh</a>&gt;</span></div><div class="line"><span class="comment">//This includes the higher-level objects</span></div><div class="line"><span class="comment">//and functions:</span></div><div class="line"><span class="preprocessor">#include &lt;fwdpp/sugar/sugar.hpp&gt;</span></div></div><!-- fragment --><h2>Library organization</h2>
<p>The two headers correspond to two related parts of <b>fwdpp</b>. The header <code><a class="el" href="../../df/df8/diploid_8hh.html" title="Main header for programming using this library. ">fwdpp/diploid.hh</a></code> contains low-level functionality. This code base represents how the library grew over time.</p>
<p>While it is possible to write your simulations using only the part of <b>fwdpp</b>, doing so is more cumbersome than it needs to be. During our work in developing simulations for our research, a series of best practices have evolved, which developed into the "sugar" part of the library (<code>fwdpp/sugar/sugar.hpp</code>).</p>
<p>We recommend using "sugar" features whenever possible. They call the low-level functions an often have simpler APIs. In the sections below, function calls from "sugar" will be noted.</p>
<p>Both the low-level and sugar parts of <b>fwdpp</b> are in the namespace <code>fwdpp</code>.</p>
<h2>Built-in types</h2>
<p>This section describes the low-level types required by a simulation.</p>
<h3>An unsigned integer</h3>
<p>The library defines this type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></div><div class="line">{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> = std::uint32_t;</div><div class="line">}</div></div><!-- fragment --><p>Thus, the name <code><a class="el" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3" title="The unsigned integer type is 32 bits. ">fwdpp::uint_t</a></code> refers to a 32-bit, unsigned integer.</p>
<h3>Diploids</h3>
<p>When modeling a single contiguous genomic segment, a diploid is simply a pair of gametes. The way to represent that using <b>fwdpp</b> is actually with a type from the C++ standard library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// This is a typedef for a diploid</span></div><div class="line"><span class="keyword">using</span> diploid = std::pair&lt;std::size_t,std::size_t&gt;</div></div><!-- fragment --><h4>Custom diploids</h4>
<p>Sometimes, you need more information associated with your diploid type. You can define a custom diploid provided that they provide the same <em>minimal API</em> the pair from the previous section.</p>
<div class="fragment"><div class="line"><span class="comment">/* This is a custom diploid</span></div><div class="line"><span class="comment"> * that is essentially a hand-coded</span></div><div class="line"><span class="comment"> * instantation of pair&lt;size_t,size_t&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct </span>minimal_custom_diploid</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> first_type = std::size_t;</div><div class="line">    <span class="keyword">using</span> second_type = std::size_t;</div><div class="line">    first_type first,second;</div><div class="line"></div><div class="line">    <span class="comment">//define constructors, etc., as needed</span></div><div class="line">};</div></div><!-- fragment --><p>The code block above will be considered a custom diploid type by <b>fwdpp</b>. Of course, this one is trivial. Realistic examples may include an integer type representing biological sex, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>diploid_with_sex</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> first_type = std::size_t;</div><div class="line">    <span class="keyword">using</span> second_type = std::size_t;</div><div class="line">    first_type first,second;</div><div class="line">    <span class="keywordtype">int</span> sex;</div><div class="line"></div><div class="line">    <span class="comment">//define appropriate constructors, etc.</span></div><div class="line">};</div></div><!-- fragment --><h4>An aside</h4>
<p>Why does <b>fwdpp</b> not simply have custom diploid types inherit from the standard pair type? Well, the standard library pair does not have a virtual destructor, meaning that it cannot be used as a base type.</p>
<h4>Possible future changes</h4>
<p>Future versions of the library may add a custom diploid base type. However, diploids get copied/moved with some regularity, meaning that it is helpful for them to be trivally constructible, etc., which discourages a class hierarchy.</p>
<h3>Multi-locus/multi-region diploids</h3>
<p>When modeling multiple contiguous regions separated by some genetic distance, a diploid is represented as a vector of single-region diploid types. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> multilocus_diploid = std::vector&lt;diploid&gt;;</div></div><!-- fragment --><p>You can also have vectors of custom diploids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> multilocus_custom_diploid = std::vector&lt;diploid_with_sex&gt;;</div></div><!-- fragment --><h4>Possible future changes</h4>
<p>When using a custom diploid, the <code>vector</code> will, of course, copy any of the associated information, leading to redundancy and a bit more memory consumption. In practice, we only update the information for the first element of the vector. However, a future version of the library may define a new data type to prevent the redundancy.</p>
<h3>Gametes</h3>
<p>A gamete is defined in the low-level part of the library (<code><a class="el" href="../../df/df8/diploid_8hh.html" title="Main header for programming using this library. ">fwdpp/diploid.hh</a></code>)`.</p>
<p>A gamete is quite simple in structure, containing the following:</p>
<ul>
<li>An unsigned integer representing how many times this specific instance of the gamete exists in the population.</li>
<li>A container of "keys" to neutral mutations</li>
<li>A container of "keys" to selected mutations</li>
</ul>
<p>A gamete is quite simple in structur, containing the following:</p>
<ul>
<li>An unsigned integer representing how many times this specific instance of the gamete exists in the population.</li>
<li>A container of "keys" to neutral mutations</li>
<li>A container of "keys" to selected mutations</li>
<li>The key type is <code>std::uint32_t</code>.</li>
</ul>
<p>Let's go right to its declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TAG = tags::standard_gamete&gt;</div><div class="line">    <span class="keyword">struct </span>gamete_base</div><div class="line">    {</div><div class="line">        <span class="comment">//Count in population</span></div><div class="line">        <a class="code" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> n;</div><div class="line">        <span class="comment">//Dispatch tag type</span></div><div class="line">        <span class="keyword">using</span> gamete_tag = TAG;</div><div class="line">        <span class="keyword">using</span> index_t = std::uint32_t;</div><div class="line">        <span class="keyword">using</span> <a class="code" href="../../d0/de1/regions_8hpp.html#a71350655a014a01b97f759a414b88337">mutation_container</a> = std::vector&lt;index_t&gt;;</div><div class="line">        <span class="comment">//Container of mutations not affecting</span></div><div class="line">        <span class="comment">//genetic value/fitness (&quot;neutral mutations&quot;)</span></div><div class="line">        <a class="code" href="../../d0/de1/regions_8hpp.html#a71350655a014a01b97f759a414b88337">mutation_container</a> mutations;</div><div class="line">        <span class="comment">//Container of mutations affecting</span></div><div class="line">        <span class="comment">//genetic value/fitness (&quot;selected mutations&quot;)</span></div><div class="line">        <a class="code" href="../../d0/de1/regions_8hpp.html#a71350655a014a01b97f759a414b88337">mutation_container</a> smutations;</div><div class="line"></div><div class="line">        <span class="comment">//Constructor</span></div><div class="line">        gamete_base(<span class="keyword">const</span> <a class="code" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> &amp;icount) noexcept;</div><div class="line"></div><div class="line">        <span class="comment">//Perfect-forwarding constructor</span></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">        gamete_base(<span class="keyword">const</span> <a class="code" href="../../dd/d84/namespacefwdpp.html#acfb5fc93f157a212587caec37cee25e3">uint_t</a> &amp;icount, T &amp;&amp;n, T &amp;&amp;s) noexcept;</div><div class="line"></div><div class="line">        <span class="comment">//Destructor is virtual,</span></div><div class="line">        <span class="comment">//so you may inherit from this type</span></div><div class="line">        <span class="keyword">virtual</span> ~gamete_base() noexcept {}</div><div class="line"></div><div class="line">        <span class="comment">//Copy/move constructors, etc.</span></div><div class="line">        <span class="comment">//are omitted for space. In C++11</span></div><div class="line">        <span class="comment">//lingo, they are declared &quot;default&quot;</span></div><div class="line"></div><div class="line">        <span class="comment">//Equality comparison</span></div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">bool</span></div><div class="line">        <a class="code" href="../../d8/d31/namespacefwdpp_1_1ts.html#a1df8628a86608fa402ff6430fc387408">operator==</a>(<span class="keyword">const</span> gamete_base&lt;TAG&gt; &amp;rhs) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>The library provides the following typedef for convenience:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></div><div class="line">{</div><div class="line">    <span class="keyword">using</span> gamete = gamete_base;</div><div class="line">}</div></div><!-- fragment --><h4>Aside: gamete_base's template type?</h4>
<p>The "TAG" type, which defaults to <code>fwdpp::tags::standard_gamete</code> can be used for compile-time dispatch. Currently, it is not used for anything, and it is only there in case of some (currently unknown) future need to distinguish different types of gametes at compile time. The tag type is given a default type value so that it can be effectively ignored for right now.</p>
<h3>Mutations</h3>
<p>A mutation is an object that publicly inherits from <code><a class="el" href="../../da/dca/structfwdpp_1_1mutation__base.html" title="Base class for mutations At minimum, a mutation must contain a position and a count in the population...">fwdpp::mutation_base</a></code>, which as the following declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../dd/d84/namespacefwdpp.html">fwdpp</a></div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>mutation_base</div><div class="line">    {</div><div class="line">        <span class="comment">//Mutation position</span></div><div class="line">        <span class="keywordtype">double</span> <a class="code" href="../../da/dca/structfwdpp_1_1mutation__base.html#a131113b98f746b23d090f23ebd3ca215">pos</a>;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">          16 bits of extra data to be associated w/this type.</span></div><div class="line"><span class="comment">          Do with it what you will. Fits into padded space in this struct,</span></div><div class="line"><span class="comment">          and doesn&#39;t affect sizeof(mutation).</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        std::uint16_t <a class="code" href="../../da/dca/structfwdpp_1_1mutation__base.html#a0c27b16a7acbbb004e3402c21dc52d19">xtra</a>;</div><div class="line">        <span class="comment">//Is the mutation neutral or not?</span></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="../../da/dca/structfwdpp_1_1mutation__base.html#ab816e51903e630e17539cd766d1e259a">neutral</a>;</div><div class="line">        <span class="comment">//Constructor</span></div><div class="line">        <span class="comment">//(Be sure to call this from </span></div><div class="line">        <span class="comment">//derived classes!)</span></div><div class="line">        <a class="code" href="../../da/dca/structfwdpp_1_1mutation__base.html#ab57e4daed9c9d299bb95db409a37b691">mutation_base</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;position,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp;isneutral = <span class="keyword">true</span>,</div><div class="line">                      <span class="keyword">const</span> std::uint16_t x = 0) noexcept;</div><div class="line">        <span class="comment">//destructor</span></div><div class="line">        virtual ~<a class="code" href="../../da/dca/structfwdpp_1_1mutation__base.html#ab57e4daed9c9d299bb95db409a37b691">mutation_base</a>() noexcept {}</div><div class="line">        <span class="comment">//The usual suite of constructors</span></div><div class="line">        <span class="comment">//are declared &quot;default&quot;, and omitted</span></div><div class="line">        <span class="comment">//here.</span></div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>The base mutation class is very simple. It records a position and the "neutrality" of the variant. In fact, it is too simple to be useful. The "sugar" layer of the library provides a set of more generally useful mutation types. In practice, we find that these satisfy most needs:</p>
<ul>
<li><code><a class="el" href="../../d9/df7/structfwdpp_1_1popgenmut.html" title="Mutations with selection, dominance, and tracking age of origin The &quot;standard&quot; mutation type for popu...">fwdpp::popgenmut</a></code> is a mutation with an effect size (<code>s</code>), dominance (<code>h</code>) and a record of when it appeared (<code>g</code>). Note that <b>fwdpp</b> does not care if <code>s</code> is an effect size on a phenotype or a "selection coefficient" in the way that population geneticists typically define the term.</li>
<li><code>fwdpp::generalmut</code> where <code>s</code> and <code>h</code> are stored as <code>std::array&lt;double,std::size_t&gt;</code>, allowing for multiple <code>s/h</code> values to be associated with a variant. Think of using this array to simulate pleiotropic effect sizes, for example. Or use a <code>std::array&lt;double,2&gt;</code> to have different effects in females vs males. Etc.</li>
<li><code>fwdpp::generalmut_vec</code> is largely equivalent to <code>fwdpp::generalmut</code>, but <code>std::vector&lt;double&gt;</code> replaces the <code>std::array</code>. Possible use cases could involve different variants having different numbers of pleitropic effects. Or, and perhaps more practically, this type can be used in other language environments that do not understand <code>std::array</code> (think <a href="http://www.cython.org">Cython</a>, which does not currently support non-type template parameters required to use <code>std::array</code>).</li>
</ul>
<p>The three types listed above are included via <code>#include &lt;fwdpp/sugar/sugar.hpp&gt;</code>. See the <a href="http://molpopgen.github.io/fwdpp/doc/html/index.html">reference manual</a> for more details about them.</p>
<p>If you have a need for a feature in a mutation that cannot be accomodated by one of the above types, simply define your own. Your mutation type must publicly interit from <code><a class="el" href="../../da/dca/structfwdpp_1_1mutation__base.html" title="Base class for mutations At minimum, a mutation must contain a position and a count in the population...">fwdpp::mutation_base</a></code>.</p>
<h3>Mutations + Gametes + Diploids = (almost) a population.</h3>
<p>Let's put the previous three sections into context:</p>
<ul>
<li>We will need a container of mutations for our simulation.</li>
<li>We will need a container of gametes for our simulation.</li>
<li>We will need a container of diploids for our simulation.</li>
</ul>
<p>Here, a container refers to a contiguous-memory container that is API compatible with the C++11 <code>std::vector</code>. In practice, we use the standard library types for all of our simulations. Thus, we may define the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">//for std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span> <span class="comment">//for std::size_t</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/df8/diploid_8hh.html">fwdpp/diploid.hh</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fwdpp/sugar.hpp&gt;</span> <span class="comment">//for fwdpp::popgenmut</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> mcont_t = std::vector&lt;fwdpp::popgenmut&gt;;</div><div class="line"><span class="keyword">using</span> gcont_t = std::vector&lt;fwdpp::gamete&gt;;</div><div class="line"><span class="keyword">using</span> diploid = std::pair&lt;std::size_t,std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> dipcont_t = std::vector&lt;diploid&gt;;</div></div><!-- fragment --><p>Let's think through these typedefs in light of the definitions of mutation, gamete, and diploid:</p>
<ul>
<li>A mutation is a fundamental type, and they are stored in a vector.</li>
<li>Gametes are stored in vectors. Gametes themselves contain vectors of <code>std::uint32_t</code>, which I said were "keys" to mutations. Those keys represent the <em>indexes</em> of the mutations present in a gamete. "Neutral" and "selected" mutations are separated in order to speed up genetic value calculations. Further, the keys are stored in <em>ascending</em> order according to <em>mutation position</em> (<code><a class="el" href="../../da/dca/structfwdpp_1_1mutation__base.html#a131113b98f746b23d090f23ebd3ca215" title="Mutation position. ">fwdpp::mutation_base::pos</a></code>). Storing things this way means that we can use <em>binary searches</em> in algorithms like recombination that depend on mutation positions.</li>
<li>A diploid is a pair of gametes. The minimal diploid is <code>std::pair&lt;std::size_t,std::size_t&gt;</code>. Those <code>size_t</code> objects are the <em>indexes</em> into the gamete container.</li>
</ul>
<p>Thus, a simulation requires three containers that all need to talk to each other:</p>
<div class="fragment"><div class="line"><span class="comment">//store our mutations</span></div><div class="line">mcont_t mutations;</div><div class="line"><span class="comment">//Store our gametes,</span></div><div class="line"><span class="comment">//which themselves contain</span></div><div class="line"><span class="comment">//location info referring</span></div><div class="line"><span class="comment">//to mutations</span></div><div class="line">gcont_t gametes;</div><div class="line"><span class="comment">//Store diploids, which</span></div><div class="line"><span class="comment">//contain the location of </span></div><div class="line"><span class="comment">//their gametes in gametes.</span></div><div class="line">dipcont_t diploids;</div></div><!-- fragment --><p>The above typedefs and code block refer to a simulation of a single contiguous region and a single population/deme. For a simulation of multiple, partially-linked regions in a single deme, we can say:</p>
<div class="fragment"><div class="line"><span class="comment">//rely on diploid def&#39;n above</span></div><div class="line"><span class="keyword">using</span> multilocus_diploid = std::vector&lt;diploid&gt;;</div><div class="line"><span class="keyword">using</span> mlocus_dipcont_t = std::vector&lt;multilocus_diploid&gt;;</div></div><!-- fragment --><p>For a multi-population simulation of a single, contiguous genomic region, we can define:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> metapop = std::vector&lt;dipcont_t&gt;;</div></div><!-- fragment --><p>If you're following along so far, you'll realize something odd. The definitions <code>mlocus_dipcont_t</code> and <code>metapop</code> are the same type ! That is true&ndash;both are aliases for <code>std::vector&lt;std::vector&lt;diploid&gt;&gt;</code>. They are distinguished from one another in the library because operations on these different population types require different argument types. In other words, template tricks are involved.</p>
<h4>Aside: <code>std::uint32_t</code> for mutation keys?</h4>
<p>The astute reader will notice that <code>fwdpp::gamete_base</code> stores mutation keys as <code>std::uint32_t</code> while <code>std::vector&lt;any mutation type&gt;::size_type</code> is almost certainly <code>std::size_t</code>, which will be 64 bits on most systems. In practice, <code>sizeof(a mutation type)</code> is sufficiently large that it is very unlikely that anyone can store more than $2^32-1$ such objects. Thus, <b>fwdpp</b> intentionally makes a compromise on the integer width. A nice side-effect is that we save a lot of memory! Those keys end up being a lot of the storage in a simulation of a large population/large genomic region.</p>
<h2>Representing a population</h2>
<p>Sadly, we need more than containers of mutations, gametes and diploids. There's more to book-keep, requiring additional data structures:</p>
<ul>
<li>We need a vector keeping track of mutation frequencies.</li>
<li>It would be handy to have a vector of fixed mutations, so that we can remove such mutations from our population (for models where doing so would be appropriate).</li>
<li>If we are tracking fixations, we probably want to track fixation times, leading to another vector recording those.</li>
<li>When simulating infinitely-many sites mutation models, an efficient lookup table of current mutation positions would be a good idea.</li>
</ul>
<p>This is where the "sugar" part of <b>fwdpp</b> comes in handy. While it would be possible to manually define all of these additional container types, it would be better if we could encapsulate all of these concepts into classes. The sugar layer defines three template types to help you:</p>
<ul>
<li><code>fwdpp::singlepop</code> to represent a contiguous region and a single deme</li>
<li><code>fwdpp::metapop</code> to represent a contiguous region and multiple demes</li>
<li><code>fwdpp::multiloc</code> to represent multiple partially-linked regions and a single deme.</li>
</ul>
<p>Each of the above takes two type parameters as template arguments. These are a mutation type and a diploid type, respectively. Further, the diploid type defaults to <code>std::pair&lt;std::size_t,std::size_t&gt;</code>. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fwdpp/sugar.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//A population type where </span></div><div class="line"><span class="comment">//the mutation type is</span></div><div class="line"><span class="comment">//fwdpp::popgenmut and</span></div><div class="line"><span class="comment">//a diploid is pair&lt;size_t,size_t&gt;</span></div><div class="line"><span class="keyword">using</span> singlepop_t </div><div class="line">    = fwdpp::singlepop&lt;fwdpp::popgenmut&gt;;</div><div class="line"></div><div class="line"><span class="comment">//A different population type based</span></div><div class="line"><span class="comment">//around a custom diploid</span></div><div class="line"><span class="keyword">using</span> singlepop_custom_t </div><div class="line">    = fwdpp::singlepop&lt;fwdpp::popgenmut,diploid_with_sex&gt;;</div></div><!-- fragment --><p>The rest of the types are filled in automatically for you. These types always use <code>std::vector</code> for contiguous-memory containers. The lookup type for mutation positions is defined in terms of <code>std::unordered_set</code>.</p>
<p>The <code>metapop</code> and <code>multiloc</code> template types work similarly.</p>
<p>These containers are defined as C++11 template aliases. The <code>singlepop</code>, <code>metapop</code>, and <code>multiloc</code> types are template aliases for <code>fwdpp::sugar::singlepop</code>, <code>fwdpp::sugar::metapop</code>, and <code>fwdpp::sugar::multiloc</code>, respectively. The types in namespace <code><a class="el" href="../../dd/d09/namespacefwdpp_1_1sugar.html">fwdpp::sugar</a></code> take more type names as template parameters. These types are the various container types, etc. Thus, if you wish to use a vector type other than <code>std::vector</code> (perhaps <code>std::vector</code> with a custom allocator, or <code>boost::vector</code>), then you may define a new template alias in terms of those container types and it will "just work", provided that the container type's API matches those of the C++ standard library types.</p>
<p>At this point, I'll refer you to the <a href="http://molpopgen.github.io/fwdpp/doc/html/index.html">reference manual</a> for more detail on these types.</p>
<h2>Recycling</h2>
<p>Mutations and gametes go extinct during the course of a simulation. For a gamete, this means that its count (<code>fwdpp::gamete_base::n</code>) is zero. For a mutation, this means that the vector tracking mutation occurences has a zero at a specific position.</p>
<p>Internally, <b>fwdpp</b> records where extinct mutations/gametes are and builds a FIFO queue of their indexes. This queue is used so that these locations can be recycled with new objects.</p>
<p>Recycling allows us to use cache-friendly containers like <code>std::vector</code>. It also allows us to re-use space allocated by gametes for their mutation keys. Overall, it is a big win in terms of performance.</p>
<h2>Modeling the biology</h2>
<p>This section gives a quick overview of what mutation, recombination, and genetic value functions have to look like in order to be compatible with <b>fwdpp</b>. After reading this document, you should go look at the source code for the example programs to get an idea of how these ideas are put into practice.</p>
<p>This section uses the following shorthand notation for types:</p>
<ul>
<li>diploid_t is a diploid</li>
<li>gamete_t is a gamete</li>
<li>mutation_t is a mutation</li>
<li>gcont_t is a container of gametes</li>
<li>mcont_t is a container of mutations</li>
</ul>
<p>In practice, the above will refer equally to both type names that are required to instantiate the library's template functions and to specific types used to instantiate the templates. The following code block shows how <code>diploid_t</code> can be both a generic name and a specific type (<code>pair&lt;size_t,size_t&gt;</code>):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> diplo<span class="keywordtype">id</span>_t&gt;</div><div class="line"><span class="keywordtype">void</span> do_something(<span class="keyword">const</span> diploid_t &amp;)</div><div class="line">{</div><div class="line">    static_assert(fwdpp::is_diploid&lt;diploid_t&gt;::value,</div><div class="line">    <span class="stringliteral">&quot;diploid_t must be a valid diploid type&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line">std::pair&lt;std::size_t,std::size_t&gt; a_diploid;</div><div class="line"></div><div class="line">do_something(a_diploid);</div></div><!-- fragment --><p>The next sections discuss functions <em>signatures</em>. By this, I mean its return type and the argument types that it expects. Further, the signature refers to the argument types <em>after</em> lambda capture and/or binding parameters via <code>std::bind</code>.</p>
<p>The signature of our <code>do_something</code> function above can be written as <code>void(const diploid_t &amp;)</code>. I will refer to signatures using their representation as a <code>std::function</code>. With this notation, we can rewrite the signature of <code>do_something</code> as</p>
<div class="fragment"><div class="line">std::function&lt;void(const diploid_t &amp;)&gt;</div></div><!-- fragment --><p>In other words, anything convertible to the above type has the same signature. In C++, this means regular functions, function objects defining <code>operator()</code>, lamba expressions, and C-style function pointers.</p>
<p>Consider the following function object:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>do_something_else</div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> diplo<span class="keywordtype">id</span>_t&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> diploid_t &amp; dip, </div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> x)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Further, consider the following object:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bound_function = </div><div class="line">    std::bind(do_something_else(),</div><div class="line">              std::placeholders::_1,2.0);</div></div><!-- fragment --><p>The signature of <code>bound_function</code> is <code>std::function&lt;void(const diploid_t &amp;)&gt;</code>. (In fact, that is one of many possible signatures, depending on what that placeholder eventually resolves to at compile time, but that detail is beyond the scope for now.)</p>
<p>Likewise, the following lambda has <code>std::function&lt;void(const diploid_t &amp;)&gt;</code> for a signature:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x = 2.0;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> a_lambda = </div><div class="line">    [x](<span class="keyword">const</span> diploid_t &amp;d) -&gt; <span class="keywordtype">void</span></div><div class="line">    {</div><div class="line">    };</div></div><!-- fragment --><p>Much of <b>fwdpp</b>'s flexibility comes from the fact that many different callable objects can reduce to the same signature after binding/lambda capture.</p>
<h3>Mutation</h3>
<p>Two types of mutation function are possible. First,</p>
<div class="fragment"><div class="line">std::function&lt;std::size_t(recycling_bin_t &amp;, mcont_t &amp;)&gt;</div></div><!-- fragment --><p>Or,</p>
<div class="fragment"><div class="line">std::function&lt;std::size_t(recycling_bin_t &amp;, const gamete_t &amp;,mcont_t &amp;)&gt;</div></div><!-- fragment --><p>The function must generate a new mutation and return its key. The key must be the index of the new mutation in the mutations container. Further, fwdpp's recycling rules must be obeyed.</p>
<p>In order to assist writing mutation functions, the library provids fwdpp::fwdpp_internal::recycle_mutation_helper. This function is a variadic template function with the following prototype:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> queue_t, <span class="keyword">typename</span> mcont_t, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="keyword">typename</span> queue_t::value_type</div><div class="line">recycle_mutation_helper(queue_t &amp;mutation_recycling_bin,</div><div class="line">                        mcont_t &amp;mutations, Args &amp;&amp;... args)</div></div><!-- fragment --><p>The parameter pack Args represent the constructor calls for the mutation type, which are perfectly-forwarded into a new mutation object. If an existing location in the mutation container cannot be recycled, a new object is emplaced at the end using the parameter pack, minimizing the number of temporary objects created. If a position can be recycled, a new object is most likely copy-constructed into place (but some compilers may implement a move construction at their discretion&ndash;most don't, though).</p>
<p>For a real-world example, see the implementation of fwdpp::infsites.</p>
<h4>Possible future changes</h4>
<ul>
<li>Move recycle_mutation_helper out of the fwdpp_internal namespace, as the public API should not be there.</li>
<li>Consider additional valid function signatures where a diploid is passed in, which may help implement things like sex-specific mutation rates, etc.</li>
<li>Design an API that allows for reversible mutation. I'm not sure fwdpp is quite there yet.</li>
</ul>
<h3>Recombination</h3>
<p>A recombination function has the following signature:</p>
<div class="fragment"><div class="line">std::function&lt;std::vector&lt;double&gt;(<span class="keyword">const</span> gamete_t &amp;, <span class="keyword">const</span> gamete_t &amp;, <span class="keyword">const</span> mcont_t &amp;)&gt;</div></div><!-- fragment --><p>This function is responsible for returning a vector of breakpoints. Any random number generators, etc., needed to generate such a vector must be bound/captured separately.</p>
<p>An example of a recombination function is fwdpp::poisson_xover, which is implemented as a function object with a template call operator.</p>
<p>This function signature is the same for a multilocus diploid. Vectors of such functions are used for multi-locus/region simulations, and they are applied in turn to each locus.</p>
<h4>Possible future changes</h4>
<p>In order to model things like sex-limited recombination, etc., will require a signature like this:</p>
<div class="fragment"><div class="line">std::function&lt;std::vector&lt;double&gt;(<span class="keyword">const</span> diploid_t &amp;, <span class="keyword">const</span> gcont_t &amp;, <span class="keyword">const</span> mcont_t &amp;)&gt;</div></div><!-- fragment --><p>Passing in the diploid type itself would allow checking of any data present in custom diploid types (male, female, etc.). It is likely that such a change will happen in a future release.</p>
<h3>Calculating a diploid's genetic value</h3>
<p>For simulations with fitness effects, we need to:</p>
<ol type="1">
<li>Take the data in a diploid's gametes and calculate some quantity. Call it the genetic value, which is a <code>double</code>.</li>
<li>Convert that value into fitness, which is a non-negative <code>double</code>.</li>
</ol>
<p>For standard population-genetic simulations, the mapping of genetic value to fitness is trivial. Often, it is as simple as <code>max(0.0,genetic_value);</code>.</p>
<p>For simulations of quantitative traits, there are probably extra steps involved:</p>
<ol type="1">
<li>Is the final trait value going to be a combination of genetic value plus random noise?</li>
<li>What is the mapping of final trait value to fitness? For example&ndash;Gaussian stabilizing selection or a linear selection gradient?</li>
</ol>
<p>For quantitative genetic simulations, the genetic value is a <code>double</code> that can take on any finite value.</p>
<p>We define the following conventions:</p>
<ol type="1">
<li>Fitnesses must be <code>w &gt;= 0</code> and a mutant-free diploid would have a fitness of <code>w = 1</code>.</li>
<li>Genetic values may take on any finite value and a mutant-free diploid would have <code>g = 0</code>.</li>
</ol>
<p>The challenge is to write functions to calculate <code>g</code> and map them onto the correct scale.</p>
<p><b>fwdpp</b> has a simple requirement for the signature of a function to calculate a genetic value:</p>
<div class="fragment"><div class="line">std::function&lt;double(const diploid_t &amp;, const gcont_t &amp;, const mcont_t &amp;)&gt;</div></div><!-- fragment --><p>In other words, it take a diploid, a container of gametes, and a container of mutations as arguments. Using that information, the genetic value is calculated and returned as a double.</p>
<p>For the case of a single locus/region simulation, the library provides efficient implementations of two standard models:</p>
<ul>
<li><code><a class="el" href="../../de/db8/structfwdpp_1_1additive__diploid.html" title="Additive fitness or trait value across sites This function object calculate the genetic value of a di...">fwdpp::additive_diploid</a></code> applies an additive model with dominance.</li>
<li><code><a class="el" href="../../d7/de7/structfwdpp_1_1multiplicative__diploid.html" title="Multiplicative fitness or trait value across sites This function object calculate the genetic value o...">fwdpp::multiplicative_diploid</a></code> applies a multiplicative model with dominance.</li>
</ul>
<p>By default, both of these function objects map genetic values to fitness when constructing the return value. This is done via calls to <code>fwdpp::aw</code> or <code>fwdpp::mw</code>, respectively. This behavior may be changed by passing in a differnt policy to the object's constructor&ndash;<code>fwdpp::atrait()</code> and <code>fwdpp::mtrait()</code>, respectively, change the behavior of each type to return a trait value centered on zero.</p>
<h4>General comments</h4>
<p>Mapping a diploid genotype to fitness is one of the most important aspects of implementing a simulation. It is also one of the most difficult, both in terms of the programming itself and because it really forces you to think about your models. For "standard pop-gen" scenarios, the default behaviors are quite simple. For quantitative trait simulations, things are more necessarily more complex, and the library allows you to do any of the following:</p>
<ol type="1">
<li>Map genetic value straight to fitness.</li>
<li>Separate genetic value from trait value from fitness calculations.</li>
</ol>
<p>The latter is very important, as it allows the flexibility of recording the <code>g</code>, <code>e</code>, and <code>w</code> values that may be part of the calculation as data, for example in a custom diploid type.</p>
<p>For more details, see the tutorials. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
