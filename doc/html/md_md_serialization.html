<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>fwdpp: Tutorial 3: Data serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.5.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 3: Data serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Intro</h2>
<p>This tutorial covers the following topics:</p>
<ul>
<li>Writing simulated populations to files, and reading them back in</li>
<li>Copying simulated population in memory</li>
</ul>
<h2>The basic functions</h2>
<p>For single-deme simulations, the library provides the following functions:</p>
<ul>
<li><a class="el" href="da/d8b/namespaceKTfwd.html#a83d6054f49a862e56e817bd1916b6ff6" title="Write population to binary-format file for individual-based simulations. ">KTfwd::write_binary_pop</a></li>
<li><a class="el" href="da/d8b/namespaceKTfwd.html#afa05ba9d97f7a5da001f6a0fdd5cc75c" title="Read the population back from a binary-format file for individual-based simulations. ">KTfwd::read_binary_pop</a></li>
</ul>
<p>These functions write and read simulated populations in a binary (<em>e.g.</em> not human-readable) format.</p>
<p>For multi-deme simulations, we have:</p>
<ul>
<li><a class="el" href="da/d8b/namespaceKTfwd.html#aedd168fa4972c3a581b44de38197abf8">KTfwd::write_binary_metapop</a></li>
<li><a class="el" href="da/d8b/namespaceKTfwd.html#ad1076a590e2ed2e9b7501423a4b87942" title="Read the metapopulation back from a binary-format file for individual-based simulations Read the meta...">KTfwd::read_binary_metapop</a></li>
</ul>
<p>As with the rest of the library, these functions are implemented using a combination of templates + function overloading.</p>
<p>Currently, these functions support the following types of simulations:</p>
<ul>
<li>single-locus, single-deme</li>
<li>single-locus, multi-deme</li>
<li>multi-locus, single-deme</li>
</ul>
<p>The type requirements for these functions are:</p>
<ul>
<li>Containers of objects used in fwdpp-based simulations (containers of gametes, mutations, diploids, etc.)</li>
<li>Output streams compatible with the public interface of <a href="http://www.cplusplus.com/reference/ostream/ostream/">std::ostream</a></li>
<li>Input streams compatible with the public interfact of <a href="http://www.cplusplus.com/reference/istream/istream/">std::istream</a></li>
<li>Input via the gzFile type defined by <a href="http://zlib.net">zlib</a></li>
</ul>
<h2>Writing and reading mutations</h2>
<p>You need to tell these functions how to read/write mutation objects. Specifically, you need to:</p>
<ul>
<li>Define a mutation write function, which takes a mutation object and an output stream type as an object.</li>
<li>Define a mutation read function, taking an input stream type as an object</li>
</ul>
<p>For a concrete example of implementing "mutation readers" and "mutation writers", see the implementation of <a class="el" href="de/d25/structKTfwd_1_1mutation__writer.html" title="Facilitates serialization of mutation types supported by the fwdpp sugar library. ...">KTfwd::mutation_writer</a> and <a class="el" href="de/d25/structKTfwd_1_1mutation__writer.html" title="Facilitates serialization of mutation types supported by the fwdpp sugar library. ...">KTfwd::mutation_writer</a>.</p>
<p>Below, you will see how to pass these to <a class="el" href="da/d8b/namespaceKTfwd.html#a83d6054f49a862e56e817bd1916b6ff6" title="Write population to binary-format file for individual-based simulations. ">KTfwd::write_binary_pop</a> and <a class="el" href="da/d8b/namespaceKTfwd.html#afa05ba9d97f7a5da001f6a0fdd5cc75c" title="Read the population back from a binary-format file for individual-based simulations. ">KTfwd::read_binary_pop</a>.</p>
<h2>Reading and writing diploids.</h2>
<p>Version 0.3.1 allowed the use of custom diploid genotype objects (<a class="el" href="md_md_customdip.html">Advanced topics: custom diploid genotypes</a>). Such objects can be serialized with no additional effort. <em>However, doing so will result in custom data associated with these custom types not being serialized.</em></p>
<p>In order to solve this, define your own custom structures for writing and reading:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>diploid_writer {</div><div class="line">        <span class="keyword">using</span> result_type = void;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> dip_itr, <span class="keyword">typename</span> streamtype &gt;</div><div class="line">        <span class="keyword">inline</span> result_type( dip_itr <a class="code" href="d5/daa/sugar__add__mutationTest_8cc.html#a904ff4f9ee77665963d354fe4c6a86e0">i</a>, streamtype &amp; o )<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">                <span class="comment">//Do the right thing here.</span></div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><p>The arguments should be an iterator pointing to one of your custom diploids, and a reference to an output stream (including a gzFile!). A function object of the same form should also be written to read the data back in.</p>
<p>These custom serialization objects may be passed as the last arguments to the functions discussed in the next section. By default, they are implicitly passed <a class="el" href="d5/d09/structKTfwd_1_1diploidIOplaceholder.html" title="placeholder IO policy for standard diploid types ">KTfwd::diploidIOplaceholder</a>, which is essentially an empty object.</p>
<h2>In-memory copying</h2>
<p>It may be desirable to be able to restore a population from a previous state. For example, you may wish to repeatedly introduce a mutation at a position, and then simulate until it is fixed. For replicates where it is lost, you will restore the population to the state it was in when you introduced the mutation. You may do this using <a class="el" href="da/d8b/namespaceKTfwd.html#a83d6054f49a862e56e817bd1916b6ff6" title="Write population to binary-format file for individual-based simulations. ">KTfwd::write_binary_pop</a> or <a class="el" href="da/d8b/namespaceKTfwd.html#aedd168fa4972c3a581b44de38197abf8">KTfwd::write_binary_metapop</a>, and write the population to an in-memory buffer such as <a href="http://www.cplusplus.com/reference/sstream/ostringstream/">std::ostringstream</a>. You may restore the population by reading the data from a <a href="http://www.cplusplus.com/reference/sstream/istringstream/">std::istringstream</a>.</p>
<p>Here is some pseudocode for an single-deme simulation:</p>
<div class="fragment"><div class="line"><span class="comment">//run a simulation...</span></div><div class="line"></div><div class="line"><span class="comment">//write it to a buffer:</span></div><div class="line">std::ostringstream buffer;</div><div class="line"><a class="code" href="da/d8b/namespaceKTfwd.html#a83d6054f49a862e56e817bd1916b6ff6">KTfwd::write_binary_pop</a>(gametes,mutations,diploids,std::bind(<a class="code" href="d5/d07/sugar__metapop__custom__diploidTest_8cc.html#adc4cb78b331fc4385057a2f785457cae">mwriter</a>(),std::placeholders::_1,std::placeholders::_2),buffer);</div><div class="line"></div><div class="line"><span class="comment">//Now, if you want to restore it:</span></div><div class="line">std::istringstream inbuffer(buffer.str());</div><div class="line">decltype(mutations) mutations2;</div><div class="line">decltype(gametes) gametes2;</div><div class="line">decltype(diploids) diploids2;</div><div class="line"><a class="code" href="da/d8b/namespaceKTfwd.html">KTfwd</a>::<a class="code" href="da/d8b/namespaceKTfwd.html#afa05ba9d97f7a5da001f6a0fdd5cc75c">read_binary_pop</a>(gametes2,</div><div class="line">                         mutations2,</div><div class="line">                         diploids2,</div><div class="line">                         <a class="code" href="d8/dcc/namespacestd.html">std</a>::bind(<a class="code" href="d7/d1a/structKTfwd_1_1mutation__reader.html">mreader</a>(),<a class="code" href="d8/dcc/namespacestd.html">std</a>::placeholders::_1),</div><div class="line">                         inbuffer);</div></div><!-- fragment --><p>This approach works because <a class="el" href="da/d8b/namespaceKTfwd.html#a83d6054f49a862e56e817bd1916b6ff6" title="Write population to binary-format file for individual-based simulations. ">KTfwd::write_binary_pop</a> and <a class="el" href="da/d8b/namespaceKTfwd.html#aedd168fa4972c3a581b44de38197abf8">KTfwd::write_binary_metapop</a> perform "deep copies" of the data, allowing the complete restoration of all the pointers, etc., stored in the containers.</p>
<h2>Writing to files</h2>
<p>You may use the same functions to write/read to from files. You may use and sort of <a href="http://www.cplusplus.com/reference/ostream/ostream/">std::ostream</a>-compatible object for output. You may use either a <a href="http://www.cplusplus.com/reference/istream/istream/">std::istream</a>-compatible object for input or a gzFile object from <a href="http://zlib.net">zlib</a>.</p>
<h2>Managing output from multiple independent processes</h2>
<p>In practice, we often implement simulations with the idea that one replicate will be run per process, and that we will spread a large number of processes across our cluster. Typically, we collect the output of these simulations into a single file. To do this, we implement POSIX-style advisory file locking. See <a href="https://github.com/molpopgen/BigDataFormats">here</a> for a discussion of how to do that using the low-level C functions found in &lt;fcntl.h&gt;. A more modern C++-based approach would be to use the <a href="http://www.boost.org">boost</a> synchronization library. See <a href="https://gist.github.com/molpopgen/651e4ac81253f34364f7">here</a> for simple examples.</p>
<h3>Why not use boost serialization?</h3>
<p>Cliff's notes version: this approach would work well for a single process writing lots of replicates to one file. However, the archives that this library creates do not support appending on to an existing library. This limitation is unfortunate, as being able to use this library would simplify some of the implementation. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
