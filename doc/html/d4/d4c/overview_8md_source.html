<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: md/overview.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">md/overview.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d4/d4c/overview_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Overview of fwdpp features</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This document is a quick tour of __fwdpp__&#39;s features.  It also points out what is missing from the library that may or may not be addressed in the future.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The document assumes a working knowledge of C++11 and skips details, such as class constructor implementation, that are C++11 issues rather than __fwdpp__ issues.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Sub-sections named &quot;aside&quot; may be skipped--they contain some technical details that hopefully address questions that proficient C++ programmers may have.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## Library headers</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;The library is header-only, meaning that there is no runtime library to link to. Rather, the vast majority of library code is implemented as generic templates.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;There are two main headers to be aware of:</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;```cpp</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;//This includes the low-level library:</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;#include &lt;fwdpp/diploid.hh&gt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;//This includes the higher-level objects</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;//and functions:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;#include &lt;fwdpp/sugar/sugar.hpp&gt;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;```</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;## Library organization</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;The two headers correspond to two related parts of __fwdpp__.  The header `fwdpp/diploid.hh` contains low-level functionality.  This code base represents how the library grew over time.  </div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;While it is possible to write your simulations using only the part of __fwdpp__, doing so is more cumbersome than it needs to be. During our work in developing simulations for our research, a series of best practices have evolved, which developed into the &quot;sugar&quot; part of the library (`fwdpp/sugar/sugar.hpp`).  </div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;We recommend using &quot;sugar&quot; features whenever possible.  They call the low-level functions an often have simpler APIs.  In the sections below, function calls from &quot;sugar&quot; will be noted.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;Both the low-level and sugar parts of __fwdpp__ are in the namespace `fwdpp`.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;## Built-in types</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;This section describes the low-level types required by a simulation.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;### An unsigned integer</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;The library defines this type:</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;```cpp</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;#include &lt;cstdint&gt;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;namespace fwdpp</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    using uint_t = std::uint32_t;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;```</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;Thus, the name `fwdpp::uint_t` refers to a 32-bit, unsigned integer.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;### Diploids</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;When modeling a single contiguous genomic segment, a diploid is simply a pair of gametes.  The way to represent that using __fwdpp__ is actually with a type from the C++ standard library:</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;```cpp</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;#include &lt;utility&gt;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;#include &lt;cstdint&gt;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;// This is a typedef for a diploid</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;using diploid = std::pair&lt;std::size_t,std::size_t&gt;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;```</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;#### Custom diploids</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;Sometimes, you need more information associated with your diploid type.  You can define a custom diploid provided that they provide the same _minimal API_ the pair from the previous section.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;```cpp</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;/* This is a custom diploid</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160; * that is essentially a hand-coded</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160; * instantation of pair&lt;size_t,size_t&gt;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160; */</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;struct minimal_custom_diploid</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    using first_type = std::size_t;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    using second_type = std::size_t;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    first_type first,second;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    //define constructors, etc., as needed</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;};</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;```</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The code block above will be considered a custom diploid type by __fwdpp__.  Of course, this one is trivial.  Realistic examples may include an integer type representing biological sex, for example:</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;```cpp</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;struct diploid_with_sex</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;{</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    using first_type = std::size_t;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    using second_type = std::size_t;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    first_type first,second;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    int sex;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    //define appropriate constructors, etc.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;};</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;```</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;#### An aside</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;Why does __fwdpp__ not simply have custom diploid types inherit from the standard pair type?  Well, the standard library pair does not have a virtual destructor, meaning that it cannot be used as a base type.  </div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;#### Possible future changes</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;Future versions of the library may add a custom diploid base type.  However, diploids get copied/moved with some regularity, meaning that it is helpful for them to be trivally constructible, etc., which discourages a class hierarchy.</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;### Multi-locus/multi-region diploids</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;When modeling multiple contiguous regions separated by some genetic distance, a diploid is represented as a vector of single-region diploid types.  For example:</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;```cpp</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;using multilocus_diploid = std::vector&lt;diploid&gt;;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;```</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;You can also have vectors of custom diploids:</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;```cpp</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;using multilocus_custom_diploid = std::vector&lt;diploid_with_sex&gt;;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;```</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;#### Possible future changes</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;When using a custom diploid, the `vector` will, of course, copy any of the associated information, leading to redundancy and a bit more memory consumption.  In practice, we only update the information for the first element of the vector. However, a future version of the library may define a new data type to prevent the redundancy.</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;### Gametes</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;A gamete is defined in the low-level part of the library (`fwdpp/diploid.hh`)`.</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;A gamete is quite simple in structure, containing the following:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;* An unsigned integer representing how many times this specific instance of the gamete exists in the population.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;* A container of &quot;keys&quot; to neutral mutations</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;* A container of &quot;keys&quot; to selected mutations</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;A gamete is quite simple in structur, containing the following:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;* An unsigned integer representing how many times this specific instance of the gamete exists in the population.</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;* A container of &quot;keys&quot; to neutral mutations</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;* A container of &quot;keys&quot; to selected mutations</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;* The key type is `std::uint32_t`.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Let&#39;s go right to its declaration:</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;```cpp</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;namespace fwdpp</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    template &lt;typename TAG = tags::standard_gamete&gt;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    struct gamete_base</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        //Count in population</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        uint_t n;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        //Dispatch tag type</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        using gamete_tag = TAG;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        using index_t = std::uint32_t;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        using mutation_container = std::vector&lt;index_t&gt;;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        //Container of mutations not affecting</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        //genetic value/fitness (&quot;neutral mutations&quot;)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        mutation_container mutations;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        //Container of mutations affecting</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        //genetic value/fitness (&quot;selected mutations&quot;)</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        mutation_container smutations;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        //Constructor</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        gamete_base(const uint_t &amp;icount) noexcept;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        //Perfect-forwarding constructor</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        template &lt;typename T&gt;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        gamete_base(const uint_t &amp;icount, T &amp;&amp;n, T &amp;&amp;s) noexcept;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        </div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        //Destructor is virtual,</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        //so you may inherit from this type</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        virtual ~gamete_base() noexcept {}</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        //Copy/move constructors, etc.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        //are omitted for space. In C++11</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        //lingo, they are declared &quot;default&quot;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        //Equality comparison</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        inline bool</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        operator==(const gamete_base&lt;TAG&gt; &amp;rhs) const;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    };</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;```</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;The library provides the following typedef for convenience:</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;```cpp</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;namespace fwdpp</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;{</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    using gamete = gamete_base;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;```</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;#### Aside: gamete_base&#39;s template type?</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;The &quot;TAG&quot; type, which defaults to `fwdpp::tags::standard_gamete` can be used for compile-time dispatch.  Currently, it is not used for anything, and it is only there in case of some (currently unknown) future need to distinguish different types of gametes at compile time.  The tag type is given a default type value so that it can be effectively ignored for right now.</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;### Mutations</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;A mutation is an object that publicly inherits from `fwdpp::mutation_base`, which as the following declaration:</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;```cpp</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;namespace fwdpp</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;{</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    struct mutation_base</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        //Mutation position</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        double pos;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        /*</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;          16 bits of extra data to be associated w/this type.</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;          Do with it what you will. Fits into padded space in this struct,</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;          and doesn&#39;t affect sizeof(mutation).</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        */</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        std::uint16_t xtra;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        //Is the mutation neutral or not?</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        bool neutral;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        //Constructor</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        //(Be sure to call this from </div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        //derived classes!)</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        mutation_base(const double &amp;position,</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                      const bool &amp;isneutral = true,</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                      const std::uint16_t x = 0) noexcept;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        //destructor</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        virtual ~mutation_base() noexcept {}</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        //The usual suite of constructors</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        //are declared &quot;default&quot;, and omitted</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        //here.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    };</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;}</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;```</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;The base mutation class is very simple.  It records a position and the &quot;neutrality&quot; of the variant.  In fact, it is too simple to be useful.  The &quot;sugar&quot; layer of the library provides a set of more generally useful mutation types.  In practice, we find that these satisfy most needs:</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;* `fwdpp::popgenmut` is a mutation with an effect size (`s`), dominance (`h`) and a record of when it appeared (`g`).  Note that __fwdpp__ does not care if `s` is an effect size on a phenotype or a &quot;selection coefficient&quot; in the way that population geneticists typically define the term.</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;* `fwdpp::generalmut` where `s` and `h` are stored as `std::array&lt;double,std::size_t&gt;`, allowing for multiple `s/h` values to be associated with a variant.  Think of using this array to simulate pleiotropic effect sizes, for example. Or use a `std::array&lt;double,2&gt;` to have different effects in females vs males.  Etc.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;* `fwdpp::generalmut_vec` is largely equivalent to `fwdpp::generalmut`, but `std::vector&lt;double&gt;` replaces the `std::array`.  Possible use cases could involve different variants having different numbers of pleitropic effects.  Or, and perhaps more practically, this type can be used in other language environments that do not understand `std::array` (think [Cython](http://www.cython.org), which does not currently support non-type template parameters required to use `std::array`).</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;The three types listed above are included via `#include &lt;fwdpp/sugar/sugar.hpp&gt;`.  See the [reference manual](http://molpopgen.github.io/fwdpp/doc/html/index.html) for more details about them.</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;If you have a need for a feature in a mutation that cannot be accomodated by one of the above types, simply define your own.  Your mutation type must publicly interit from `fwdpp::mutation_base`.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;### Mutations + Gametes + Diploids = (almost) a population.</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;Let&#39;s put the previous three sections into context:</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;* We will need a container of mutations for our simulation.</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;* We will need a container of gametes for our simulation.</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;* We will need a container of diploids for our simulation.</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;Here, a container refers to a contiguous-memory container that is API compatible with the C++11 `std::vector`. In practice, we use the standard library types for all of our simulations.  Thus, we may define the following:</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;```cpp</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;#include &lt;utility&gt; //for std::pair</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;#include &lt;cstdlib&gt; //for std::size_t</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;#include &lt;fwdpp/diploid.hh&gt;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;#include &lt;fwdpp/sugar.hpp&gt; //for fwdpp::popgenmut</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;using mcont_t = std::vector&lt;fwdpp::popgenmut&gt;;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;using gcont_t = std::vector&lt;fwdpp::gamete&gt;;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;using diploid = std::pair&lt;std::size_t,std::size_t&gt;;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;using dipcont_t = std::vector&lt;diploid&gt;;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;```</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;Let&#39;s think through these typedefs in light of the definitions of mutation, gamete, and diploid:</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;* A mutation is a fundamental type, and they are stored in a vector.</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;* Gametes are stored in vectors.  Gametes themselves contain vectors of `std::uint32_t`, which I said were &quot;keys&quot; to mutations.  Those keys represent the _indexes_ of the mutations present in a gamete.  &quot;Neutral&quot; and &quot;selected&quot; mutations are separated in order to speed up genetic value calculations.  Further, the keys are stored in _ascending_ order according to _mutation position_ (`fwdpp::mutation_base::pos`).  Storing things this way means that we can use _binary searches_ in algorithms like recombination that depend on mutation positions.</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;* A diploid is a pair of gametes.  The minimal diploid is `std::pair&lt;std::size_t,std::size_t&gt;`.  Those `size_t` objects are the _indexes_ into the gamete container.</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;Thus, a simulation requires three containers that all need to talk to each other:</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;```cpp</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;//store our mutations</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;mcont_t mutations;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;//Store our gametes,</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;//which themselves contain</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;//location info referring</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;//to mutations</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;gcont_t gametes;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;//Store diploids, which</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;//contain the location of </div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;//their gametes in gametes.</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;dipcont_t diploids;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;```</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;The above typedefs and code block refer to a simulation of a single contiguous region and a single population/deme. For a simulation of multiple, partially-linked regions in a single deme, we can say:</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;```cpp</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;//rely on diploid def&#39;n above</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;using multilocus_diploid = std::vector&lt;diploid&gt;;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;using mlocus_dipcont_t = std::vector&lt;multilocus_diploid&gt;;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;```</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;For a multi-population simulation of a single, contiguous genomic region, we can define:</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;```cpp</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;using metapop = std::vector&lt;dipcont_t&gt;;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;```</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;If you&#39;re following along so far, you&#39;ll realize something odd.  The definitions `mlocus_dipcont_t` and `metapop` are the same type ! That is true--both are aliases for `std::vector&lt;std::vector&lt;diploid&gt;&gt;`. They are distinguished from one another in the library because operations on these different population types require different argument types.  In other words, template tricks are involved. </div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;#### Aside: `std::uint32_t` for mutation keys?</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;The astute reader will notice that `fwdpp::gamete_base` stores mutation keys as `std::uint32_t` while `std::vector&lt;any mutation type&gt;::size_type` is almost certainly `std::size_t`, which will be 64 bits on most systems.  In practice, `sizeof(a mutation type)` is sufficiently large that it is very unlikely that anyone can store more than $2^32-1$ such objects.  Thus, __fwdpp__ intentionally makes a compromise on the integer width.  A nice side-effect is that we save a lot of memory!  Those keys end up being a lot of the storage in a simulation of a large population/large genomic region.</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;## Representing a population</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;Sadly, we need more than containers of mutations, gametes and diploids.  There&#39;s more to book-keep, requiring additional data structures:</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;* We need a vector keeping track of mutation frequencies.</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;* It would be handy to have a vector of fixed mutations, so that we can remove such mutations from our population (for models where doing so would be appropriate).</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;* If we are tracking fixations, we probably want to track fixation times, leading to another vector recording those.</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;* When simulating infinitely-many sites mutation models, an efficient lookup table of current mutation positions would be a good idea.</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;This is where the &quot;sugar&quot; part of __fwdpp__ comes in handy.  While it would be possible to manually define all of these additional container types, it would be better if we could encapsulate all of these concepts into classes. The sugar layer defines three template types to help you: </div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;* `fwdpp::singlepop` to represent a contiguous region and a single deme</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;* `fwdpp::metapop` to represent a contiguous region and multiple demes</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;* `fwdpp::multiloc` to represent multiple partially-linked regions and a single deme.</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;Each of the above takes two type parameters as template arguments.  These are a mutation type and a diploid type, respectively.  Further, the diploid type defaults to `std::pair&lt;std::size_t,std::size_t&gt;`.  For example:</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;```cpp</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;#include &lt;fwdpp/sugar.hpp&gt;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;//A population type where </div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;//the mutation type is</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;//fwdpp::popgenmut and</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;//a diploid is pair&lt;size_t,size_t&gt;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;using singlepop_t </div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    = fwdpp::singlepop&lt;fwdpp::popgenmut&gt;;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;//A different population type based</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;//around a custom diploid</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;using singlepop_custom_t </div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    = fwdpp::singlepop&lt;fwdpp::popgenmut,diploid_with_sex&gt;;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;```</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;The rest of the types are filled in automatically for you.  These types always use `std::vector` for contiguous-memory containers.  The lookup type for mutation positions is defined in terms of `std::unordered_set`.</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;The `metapop` and `multiloc` template types work similarly.</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;These containers are defined as C++11 template aliases.  The `singlepop`, `metapop`, and `multiloc` types are template aliases for `fwdpp::sugar::singlepop`, `fwdpp::sugar::metapop`, and `fwdpp::sugar::multiloc`, respectively.  The types in namespace `fwdpp::sugar` take more type names as template parameters.  These types are the various container types, etc.  Thus, if you wish to use a vector type other than `std::vector` (perhaps `std::vector` with a custom allocator, or `boost::vector`), then you may define a new template alias in terms of those container types and it will &quot;just work&quot;, provided that the container type&#39;s API matches those of the C++ standard library types. </div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;At this point, I&#39;ll refer you to the [reference manual](http://molpopgen.github.io/fwdpp/doc/html/index.html) for more detail on these types. </div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;## Recycling</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;Mutations and gametes go extinct during the course of a simulation.  For a gamete, this means that its count (`fwdpp::gamete_base::n`) is zero.  For a mutation, this means that the vector tracking mutation occurences has a zero at a specific position.</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;Internally, __fwdpp__ records where extinct mutations/gametes are and builds a FIFO queue of their indexes.  This queue is used so that these locations can be recycled with new objects.</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;Recycling allows us to use cache-friendly containers like `std::vector`.  It also allows us to re-use space allocated by gametes for their mutation keys.  Overall, it is a big win in terms of performance.</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;## Modeling the biology</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;This section gives a quick overview of what mutation, recombination, and genetic value functions have to look like in order to be compatible with __fwdpp__.  After reading this document, you should go look at the source code for the example programs to get an idea of how these ideas are put into practice.</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;This section uses the following shorthand notation for types:</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;* diploid_t is a diploid</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;* gamete_t is a gamete</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;* mutation_t is a mutation</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;* gcont_t is a container of gametes</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;* mcont_t is a container of mutations</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;In practice, the above will refer equally to both type names that are required to instantiate the library&#39;s template functions and to specific types used to instantiate the templates.  The following code block shows how `diploid_t` can be both a generic name and a specific type (`pair&lt;size_t,size_t&gt;`):</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;```cpp</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;template&lt;typename diploid_t&gt;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;void do_something(const diploid_t &amp;)</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;{</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    static_assert(fwdpp::is_diploid&lt;diploid_t&gt;::value,</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    &quot;diploid_t must be a valid diploid type&quot;);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;}</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;std::pair&lt;std::size_t,std::size_t&gt; a_diploid;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;do_something(a_diploid);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;```</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;The next sections discuss functions _signatures_.  By this, I mean its return type and the argument types that it expects. Further, the signature refers to the argument types _after_ lambda capture and/or binding parameters via `std::bind`.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;The signature of our `do_something` function above can be written as `void(const diploid_t &amp;)`.  I will refer to signatures using their representation as a `std::function`.  With this notation, we can rewrite the signature of `do_something` as</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;```cpp</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;std::function&lt;void(const diploid_t &amp;)&gt;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;```</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;In other words, anything convertible to the above type has the same signature.  In C++, this means regular functions, function objects defining `operator()`, lamba expressions, and C-style function pointers.</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;Consider the following function object:</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;```cpp</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;struct do_something_else</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;{</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    template&lt;typename diploid_t&gt;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    void operator()(const diploid_t &amp; dip, </div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                    const double x) const</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;};</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;```</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;Further, consider the following object:</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;```cpp</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;auto bound_function = </div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    std::bind(do_something_else(),</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;              std::placeholders::_1,2.0);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;```</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;The signature of `bound_function` is  `std::function&lt;void(const diploid_t &amp;)&gt;`. (In fact, that is one of many possible signatures, depending on what that placeholder eventually resolves to at compile time, but that detail is beyond the scope for now.)</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;Likewise, the following lambda has `std::function&lt;void(const diploid_t &amp;)&gt;` for a signature:</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;```cpp</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;double x = 2.0;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;auto a_lambda = </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    [x](const diploid_t &amp;d) -&gt; void</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    };</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;```</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;Much of __fwdpp__&#39;s flexibility comes from the fact that many different callable objects can reduce to the same signature after binding/lambda capture.</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;### Mutation</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;Two types of mutation function are possible.  First,</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;```cpp</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;std::function&lt;std::size_t(recycling_bin_t &amp;, mcont_t &amp;)&gt;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;```</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;Or,</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;```cpp</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;std::function&lt;std::size_t(recycling_bin_t &amp;, const gamete_t &amp;,mcont_t &amp;)&gt;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;```</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;The function must generate a new mutation and return its key.  The key must be the index of the new mutation in the mutations container.  Further, fwdpp&#39;s recycling rules must be obeyed.</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;In order to assist writing mutation functions, the library provids fwdpp::fwdpp_internal::recycle_mutation_helper.  This function is a variadic template function with the following prototype:</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;```cpp</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;template &lt;typename queue_t, typename mcont_t, class... Args&gt;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;typename queue_t::value_type</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;recycle_mutation_helper(queue_t &amp;mutation_recycling_bin,</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                        mcont_t &amp;mutations, Args &amp;&amp;... args)</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;```</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;The parameter pack Args represent the constructor calls for the mutation type, which are perfectly-forwarded into a new mutation object. If an existing location in the mutation container cannot be recycled, a new object is emplaced at the end using the parameter pack, minimizing the number of temporary objects created.  If a position can be recycled, a new object is most likely copy-constructed into place (but some compilers may implement a move construction at their discretion--most don&#39;t, though).</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;For a real-world example, see the implementation of fwdpp::infsites.</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;#### Possible future changes</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;* Move recycle_mutation_helper out of the fwdpp_internal namespace, as the public API should not be there.</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;* Consider additional valid function signatures where a diploid is passed in, which may help implement things like sex-specific mutation rates, etc.</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;* Design an API that allows for reversible mutation.  I&#39;m not sure fwdpp is quite there yet.</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;### Recombination</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;A recombination function has the following signature:</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;```cpp</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;std::function&lt;std::vector&lt;double&gt;(const gamete_t &amp;, const gamete_t &amp;, const mcont_t &amp;)&gt;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;```</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;This function is responsible for returning a vector of breakpoints.  Any random number generators, etc., needed to generate such a vector must be bound/captured separately.</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;An example of a recombination function is fwdpp::poisson_xover, which is implemented as a function object with a template call operator.</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;This function signature is the same for a multilocus diploid.  Vectors of such functions are used for multi-locus/region simulations, and they are applied in turn to each locus.</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;#### Possible future changes</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;In order to model things like sex-limited recombination, etc., will require a signature like this:</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;```cpp</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;std::function&lt;std::vector&lt;double&gt;(const diploid_t &amp;, const gcont_t &amp;, const mcont_t &amp;)&gt;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;```</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;Passing in the diploid type itself would allow checking of any data present in custom diploid types (male, female, etc.).  It is likely that such a change will happen in a future release.</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;### Calculating a diploid&#39;s genetic value</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;For simulations with fitness effects, we need to:</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;1. Take the data in a diploid&#39;s gametes and calculate some quantity.  Call it the genetic value, which is a `double`.</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;2. Convert that value into fitness, which is a non-negative `double`.</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;For standard population-genetic simulations, the mapping of genetic value to fitness is trivial.  Often, it is as simple as `max(0.0,genetic_value);`.</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;For simulations of quantitative traits, there are probably extra steps involved:</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;1. Is the final trait value going to be a combination of genetic value plus random noise?</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;2. What is the mapping of final trait value to fitness?  For example--Gaussian stabilizing selection or a linear selection gradient?</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;For quantitative genetic simulations, the genetic value is a `double` that can take on any finite value.</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;We define the following conventions:</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;1. Fitnesses must be `w &gt;= 0` and a mutant-free diploid would have a fitness of `w = 1`. </div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;2. Genetic values may take on any finite value and a mutant-free diploid would have `g = 0`.</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;The challenge is to write functions to calculate `g` and map them onto the correct scale.</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;__fwdpp__ has a simple requirement for the signature of a function to calculate a genetic value:</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;```cpp</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;std::function&lt;double(const diploid_t &amp;, const gcont_t &amp;, const mcont_t &amp;)&gt;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;```</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;In other words, it take a diploid, a container of gametes, and a container of mutations as arguments.  Using that information, the genetic value is calculated and returned as a double.</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;For the case of a single locus/region simulation, the library provides efficient implementations of two standard models:</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;* `fwdpp::additive_diploid` applies an additive model with dominance.</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;* `fwdpp::multiplicative_diploid` applies a multiplicative model with dominance.</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;By default, both of these function objects map genetic values to fitness when constructing the return value.  This is done via calls to `fwdpp::aw` or `fwdpp::mw`, respectively.  This behavior may be changed by passing in a differnt policy to the object&#39;s constructor--`fwdpp::atrait()` and `fwdpp::mtrait()`, respectively, change the behavior of each type to return a trait value centered on zero.</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;#### General comments</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;Mapping a diploid genotype to fitness is one of the most important aspects of implementing a simulation.  It is also one of the most difficult, both in terms of the programming itself and because it really forces you to think about your models.  For &quot;standard pop-gen&quot; scenarios, the default behaviors are quite simple.  For quantitative trait simulations, things are more necessarily more complex, and the library allows you to do any of the following:</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;1. Map genetic value straight to fitness.</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;2. Separate genetic value from trait value from fitness calculations.</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;The latter is very important, as it allows the flexibility of recording the `g`, `e`, and `w` values that may be part of the calculation as data, for example in a custom diploid type.</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;For more details, see the tutorials.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
