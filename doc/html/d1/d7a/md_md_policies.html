<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fwdpp: Tutorial 1: Policies in fwdpp</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fwdpp
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 1: Policies in fwdpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TutIntro">Introduction</a></li>
<li class="level1"><a href="#TutGeneral">Policies in C++</a></li>
<li class="level1"><a href="#fwdppPolicies">Policies in fwdpp</a><ul><li class="level2"><a href="#TutMut">Mutation policies</a></li>
<li class="level2"><a href="#TutRec">Recombination policies</a></li>
<li class="level2"><a href="#TutFitness">Genetic value policies</a></li>
<li class="level2"><a href="#TutRemoval">&quot;Removal policies&quot;</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TutIntro"></a>
Introduction</h1>
<p>Please read <a class="el" href="../../d5/d00/md_md_datatypes.html">Tutorial 0: Data types in fwdpp</a> and <a class="el" href="../../d2/d0a/md_md_details.html">Implementation details</a> before reading this document.</p>
<p>This document is intended to be an in-depth discussion of policies and their role in implementing forward-time population genetic simulations using the C++ template library <b>fwdpp</b>. We will first describe what policies are using standard C++ examples, and then we will get into the harder stuff.</p>
<p>An understanding of C++ fundamentals, including containers, their iterators, and how they relate to the standard algorithms, is assumed knowledge here.</p>
<h1><a class="anchor" id="TutGeneral"></a>
Policies in C++</h1>
<p>The behavior of a function may be modified by a policy. For example, [std::sort] defaults to sorting in ascending order:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; x{5,4,3,2,1};</div><div class="line">std::sort(x.begin(),x.end()); <span class="comment">//x will now contain 1,2,3,4,5</span></div></div><!-- fragment --><p>This default behavior may be modified by passing a custom function ("policy") as an additional argument. In C++, this function can take on several different forms, including function objects, lambda expression, and instances of std::function. Here is an <em>incomplete</em> list of the various ways you could sort in ascending order:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../db/d46/custom__diploid_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div><div class="line">        vector&lt;int&gt; x{5,4,3,2,1};</div><div class="line"></div><div class="line">        sort(x.begin(),x.end()); <span class="comment">//x is now 1,2,3,4,5</span></div><div class="line"></div><div class="line">        <span class="comment">//sort x in ascending order via std::greater...</span></div><div class="line">        sort(x.begin(),x.end(),bind(greater&lt;int&gt;(),placeholders::_1,placeholders::_2));</div><div class="line"></div><div class="line">        <span class="comment">//...or a lambda function...</span></div><div class="line">        sort(x.begin(),x.end(),[](<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a&gt;b; });</div><div class="line"></div><div class="line">        <span class="comment">//...or a std::function wrapping a lambda...</span></div><div class="line">        std::function&lt;bool(int,int)&gt; sorter = [](<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b){<span class="keywordflow">return</span> a&gt;b;};</div><div class="line">        sort(x.begin(),x.end(),sorter);</div><div class="line"></div><div class="line">        <span class="comment">//...or a std::function wrapping bind/greater...</span></div><div class="line">        sorter = std::bind(greater&lt;int&gt;(),placeholders::_1,placeholders::_2);</div><div class="line">        sort(x.begin(),x.end(),sorter);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="fwdppPolicies"></a>
Policies in fwdpp</h1>
<p>Just like the STL, custom functions modify the behavior of simulations. These policies affect how mutation, recombination, and selection all work. Additionally, policies may affect how mutations are removed from gametes and/or the entire population at the end of each generation. For example, consider a neutral mutation that fixed in the most recent generation. There is really no point in keeping a key to it in every gamete. Rather, we may prefer to remove it from each gamete and store it in a vector of fixations. Doing so requires a policy passed to <a class="el" href="../../dd/d84/namespacefwdpp.html#aceda5d4070606706887d0e32d2ad843b">fwdpp::sample_diploid</a> telling it to remove neutral mutations. In the case of selected mutations, we may or may not want to remove such fixed variants from gametes, depending on the context of our simulation (standard pop-gen where fixed selective mutations no longer affect relative fitness vs quantitative trait simulations where they do contribute to trait values, and thus affect distance to optimium, etc.).</p>
<h2><a class="anchor" id="TutMut"></a>
Mutation policies</h2>
<p>A mutation model has one of the following function signatures. Either</p>
<div class="fragment"><div class="line">std::size_t mutmodel(queue_t &amp;,mcont_t &amp;);</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">std::size_t mutmodel(gamete_t &amp;,mcont_t &amp;, queue_t &amp;);</div></div><!-- fragment --><p>The former is used when the current state of a gamete doesn't matter. The infinitely-many sites model is an example. The latter is used whn the current state of a gamete does matter. A finite-sites model would be an example. Internally, the library detects which type is being used. The return value is the index in the mutation container where the new mutation was placed. This location may have been generated via recycling, and the library provides fwdpp::fwdpp_internal::recycle_mutation_helper to facilitate this operation.</p>
<p>Additional model parameters are possible via the usual mechanisms: class members, std::bind, etc.</p>
<p>A valid mutation policy passes a static assertion involving fwdpp::traits::valid_mutation_model at compile time. See type_traitsTest.cc for an example of this assertion.</p>
<p>For an example of how to compose a mutation policy, see <a class="el" href="../../d4/d99/custom_mutation_8cc-example.html">custom_mutation.cc</a>.</p>
<h2><a class="anchor" id="TutRec"></a>
Recombination policies</h2>
<p>The function signature of a recombination policy must be equivalent to fwdpp::traits::recmodel_t. If so, then a static assertion involving fwdpp::traits::valid_rec_model will pass at compile time. See type_traitsTest.cc for an example of this assertion.</p>
<p>Additional model parameters are possible via the usual mechanisms: class members, std::bind, etc.</p>
<ul>
<li>fwdpp::poisson_xover</li>
</ul>
<h2><a class="anchor" id="TutFitness"></a>
Genetic value policies</h2>
<ul>
<li><a class="el" href="../../d9/d75/structfwdpp_1_1site__dependent__genetic__value.html" title="Function object for fitness/trait value as a function of individual mutations in a diploid...">fwdpp::site_dependent_genetic_value</a></li>
<li><a class="el" href="../../de/db8/structfwdpp_1_1additive__diploid.html" title="Additive fitness or trait value across sites This function object calculate the genetic value of a di...">fwdpp::additive_diploid</a></li>
<li><a class="el" href="../../d7/de7/structfwdpp_1_1multiplicative__diploid.html" title="Multiplicative fitness or trait value across sites This function object calculate the genetic value o...">fwdpp::multiplicative_diploid</a></li>
</ul>
<h2><a class="anchor" id="TutRemoval"></a>
"Removal policies"</h2>
<p>The default is std::true_type, which means that all fixations are removed from gametes.</p>
<ul>
<li><a class="el" href="../../db/dac/structfwdpp_1_1remove__nothing.html">fwdpp::remove_nothing</a></li>
<li><a class="el" href="../../d3/d73/structfwdpp_1_1remove__neutral.html" title="Policy telling library to remove neutral mutations from haploid_genomes after sampling. ">fwdpp::remove_neutral</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
